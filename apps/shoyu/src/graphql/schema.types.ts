/*  Auto-generated by graphql-codegen. Do not edit.  */
/* eslint-disable */
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Date: any;
  DateTime: Date;
  EntityId: any;
  JSON: any;
  TargetAttributeRuleFields: any;
  TargetValueScalarType: any;
};

export type Account = {
  __typename?: 'Account';
  accountUsers: Array<AccountUser>;
  archived: Scalars['Boolean'];
  /** The attributes associated with this account */
  attributes: Scalars['JSON'];
  blockedAt?: Maybe<Scalars['DateTime']>;
  blockedBy?: Maybe<User>;
  /** When the account was created in the organization (as opposed to within Bento) */
  createdInOrganizationAt?: Maybe<Scalars['DateTime']>;
  entityId: Scalars['EntityId'];
  /** The user-supplied unique ID for the Account */
  externalId?: Maybe<Scalars['String']>;
  /** The guide bases belonging to the account */
  guideBases: Array<GuideBase>;
  /** The count of guide-bases in the account */
  guideBasesCount: Scalars['Int'];
  /** Does the account have an active account onboarding guide */
  hasActiveAccountGuide: Scalars['Boolean'];
  /** Does the account have an active guide with the given template */
  hasGuideBaseWithTemplate: Scalars['Boolean'];
  /** Determine whether the account has at least one guide */
  hasGuides: Scalars['Boolean'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** Last time a user was active in this account */
  lastActiveAt?: Maybe<Scalars['DateTime']>;
  /** The name of the account */
  name: Scalars['String'];
  /** The count of participants who viewed guides */
  participantsWhoViewedGuidesCount: Scalars['Int'];
  primaryContact?: Maybe<User>;
};


export type AccountHasGuideBaseWithTemplateArgs = {
  templateEntityId?: InputMaybe<Scalars['EntityId']>;
};

export type AccountUser = {
  __typename?: 'AccountUser';
  /** The account for whom this user belongs */
  account: Account;
  /** The attributes associated with this account */
  attributes: Scalars['JSON'];
  /** @deprecated does not exist anymore, will be removed */
  avatarUrl?: Maybe<Scalars['String']>;
  createdInOrganizationAt?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  entityId: Scalars['EntityId'];
  externalId?: Maybe<Scalars['String']>;
  fullName?: Maybe<Scalars['String']>;
  /** The ID of an object */
  id: Scalars['ID'];
  /** The last guide the user interacted with */
  latestGuide?: Maybe<Scalars['JSON']>;
};

/** Shadow style of active steps */
export enum ActiveStepShadowType {
  Custom = 'custom',
  None = 'none',
  Standard = 'standard'
}

/** Additional branding colors of an org */
export type AdditionalColorsType = {
  __typename?: 'AdditionalColorsType';
  value: Scalars['String'];
};

export type AllGuidesStyleType = {
  __typename?: 'AllGuidesStyleType';
  activeGuidesTitle: Scalars['String'];
  allGuidesTitle: Scalars['String'];
  previousAnnouncementsTitle: Scalars['String'];
  previousGuidesTitle: Scalars['String'];
};

/** Name and count of CTA activity */
export type AnnouncementCtaActivity = {
  __typename?: 'AnnouncementCtaActivity';
  count: Scalars['Int'];
  /** This can be null if the original CTA associated was changed or removed */
  cta?: Maybe<GuideBaseStepCta>;
  ctaEntityId?: Maybe<Scalars['EntityId']>;
  /** Label of the CTA in question */
  text: Scalars['String'];
};

/** The box shadow for announcements */
export enum AnnouncementShadowType {
  None = 'none',
  Standard = 'standard'
}

/** Announcement activity data for one day, used with time series */
export type AnnouncementTimeSeriesPoint = {
  __typename?: 'AnnouncementTimeSeriesPoint';
  ctaActivity: Array<Maybe<AnnouncementCtaActivity>>;
  date: Scalars['Date'];
  dismissed: Scalars['Int'];
  savedForLater: Scalars['Int'];
  viewed: Scalars['Int'];
};

export type AnswerNpsSurveyInput = {
  /** NPS Score given by the end-user */
  answer: Scalars['Int'];
  /** Entity ID of the NPS survey */
  entityId: Scalars['EntityId'];
  /** Answer to the follow-up question given by the end-user */
  fupAnswer?: InputMaybe<Scalars['String']>;
};

export type AnswerNpsSurveyPayload = {
  __typename?: 'AnswerNpsSurveyPayload';
  errors?: Maybe<Array<Scalars['String']>>;
  npsSurvey?: Maybe<EmbedNpsSurvey>;
};

export enum AttributeValueType {
  Audience = 'audience',
  Boolean = 'boolean',
  BranchingPath = 'branchingPath',
  Date = 'date',
  Number = 'number',
  StringArray = 'stringArray',
  Template = 'template',
  Text = 'text'
}

export enum AttributeValueTypeEnumType {
  Audience = 'audience',
  Boolean = 'boolean',
  BranchingPath = 'branchingPath',
  Date = 'date',
  Number = 'number',
  StringArray = 'stringArray',
  Template = 'template',
  Text = 'text'
}

export type AutoCompleteInteraction = OnGuideCompletion;

export enum AutoCompleteInteractionType {
  GuideCompletion = 'guide_completion'
}

/** The inner padding of banners */
export enum BannerPaddingType {
  Large = 'large',
  Medium = 'medium',
  Small = 'small'
}

export enum BannerPosition {
  Bottom = 'bottom',
  Top = 'top'
}

export type BannerStyle = {
  __typename?: 'BannerStyle';
  backgroundColor?: Maybe<Scalars['String']>;
  bannerPosition: BannerPosition;
  bannerType: BannerType;
  canDismiss?: Maybe<Scalars['Boolean']>;
  ctasOrientation?: Maybe<CtasOrientation>;
  textColor?: Maybe<Scalars['String']>;
};

export enum BannerType {
  Floating = 'floating',
  Inline = 'inline'
}

/** The org banners styles */
export type BannersStyleStyleType = {
  __typename?: 'BannersStyleStyleType';
  borderRadius?: Maybe<Scalars['Int']>;
  padding?: Maybe<BannerPaddingType>;
  shadow?: Maybe<AnnouncementShadowType>;
};

/** What integration this key is for */
export enum BentoApiKeyTypeEnum {
  Api = 'api'
}

export type BranchingBaseStyle = {
  __typename?: 'BranchingBaseStyle';
  formFactor?: Maybe<Scalars['String']>;
};

export type BranchingCardStyle = {
  __typename?: 'BranchingCardStyle';
  backgroundImagePosition: CyoaBackgroundImagePosition;
  backgroundImageUrl?: Maybe<Scalars['String']>;
  formFactor?: Maybe<Scalars['String']>;
};

export type BranchingChoice = {
  __typename?: 'BranchingChoice';
  choiceKey?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  selected?: Maybe<Scalars['Boolean']>;
  /** Branching style based on the branching form factor */
  style?: Maybe<BranchingStyle>;
};

/** Branching Entity Type */
export enum BranchingEntityTypeEnum {
  Guide = 'guide',
  Module = 'module',
  Template = 'template'
}

/** How branching will be displayed on the embeddable */
export enum BranchingFormFactorEnumType {
  Cards = 'cards',
  Dropdown = 'dropdown'
}

export type BranchingPath = {
  __typename?: 'BranchingPath';
  /** The type of action that is performed */
  actionType: BranchingPathActionType;
  branchingKey?: Maybe<Scalars['String']>;
  choiceKey?: Maybe<Scalars['String']>;
  entityId: Scalars['EntityId'];
  /** The type of entity that is created by the action */
  entityType: BranchingPathEntityType;
  /** The ID of an object */
  id: Scalars['ID'];
  /** If the entityType is "module", the module that gets added onto the users guide */
  module?: Maybe<Module>;
  /** The entity id for the template associated with this branch */
  moduleEntityId?: Maybe<Scalars['EntityId']>;
  orderIndex?: Maybe<Scalars['Int']>;
  /** If the entityType is "template" or "guide", the template from which a guide is generated */
  template?: Maybe<Template>;
  /** The entity id for the template associated with this branch */
  templateEntityId?: Maybe<Scalars['EntityId']>;
  triggeredCount: Scalars['Int'];
};

export enum BranchingPathActionType {
  Create = 'create'
}

export enum BranchingPathEntityType {
  Guide = 'guide',
  Module = 'module',
  /** @deprecated Use "guide" */
  Template = 'template'
}

/** Branching performance by destination, for step group branching */
export type BranchingPerformance = {
  __typename?: 'BranchingPerformance';
  branchingPath?: Maybe<BranchingPath>;
  count: Scalars['Int'];
  /** Step group targeted by branching */
  createdModule?: Maybe<Module>;
  /** Guide targeted by branching */
  createdTemplate?: Maybe<Template>;
};

export type BranchingQuestion = {
  __typename?: 'BranchingQuestion';
  branchingKey: Scalars['String'];
  choices: Array<BranchingQuestionChoice>;
  id: Scalars['String'];
  question: Scalars['String'];
};

export type BranchingQuestionChoice = {
  __typename?: 'BranchingQuestionChoice';
  choiceKey: Scalars['String'];
  id: Scalars['String'];
  label: Scalars['String'];
};

export type BranchingStyle = BranchingBaseStyle | BranchingCardStyle;

export enum CyoaBackgroundImagePosition {
  Background = 'background',
  Bottom = 'bottom',
  Left = 'left',
  Right = 'right',
  Top = 'top'
}

export type CardStyle = {
  __typename?: 'CardStyle';
  advancedPadding?: Maybe<Scalars['String']>;
  backgroundColor?: Maybe<Scalars['String']>;
  borderColor?: Maybe<Scalars['String']>;
  borderRadius?: Maybe<Scalars['Int']>;
  canDismiss?: Maybe<Scalars['Boolean']>;
  ctasOrientation?: Maybe<CtasOrientation>;
  height?: Maybe<Scalars['Int']>;
  horizontalMediaAlignment?: Maybe<HorizontalMediaAlignment>;
  imageWidth?: Maybe<Scalars['String']>;
  mediaFontSize?: Maybe<Scalars['Int']>;
  mediaOrientation?: Maybe<MediaOrientation>;
  mediaTextColor?: Maybe<Scalars['String']>;
  padding?: Maybe<Scalars['Int']>;
  stepBodyOrientation?: Maybe<StepBodyOrientation>;
  textColor?: Maybe<Scalars['String']>;
  verticalMediaAlignment?: Maybe<VerticalMediaAlignment>;
  verticalMediaOrientation?: Maybe<VerticalMediaOrientation>;
};

export type CarouselStyle = {
  __typename?: 'CarouselStyle';
  advancedPadding?: Maybe<Scalars['String']>;
  backgroundColor?: Maybe<Scalars['String']>;
  borderColor?: Maybe<Scalars['String']>;
  borderRadius?: Maybe<Scalars['Int']>;
  canDismiss?: Maybe<Scalars['Boolean']>;
  ctasOrientation?: Maybe<CtasOrientation>;
  dotsColor?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['Int']>;
  horizontalMediaAlignment?: Maybe<HorizontalMediaAlignment>;
  imageWidth?: Maybe<Scalars['String']>;
  mediaFontSize?: Maybe<Scalars['Int']>;
  mediaOrientation?: Maybe<MediaOrientation>;
  mediaTextColor?: Maybe<Scalars['String']>;
  padding?: Maybe<Scalars['Int']>;
  stepBodyOrientation?: Maybe<StepBodyOrientation>;
  textColor?: Maybe<Scalars['String']>;
  verticalMediaAlignment?: Maybe<VerticalMediaAlignment>;
  verticalMediaOrientation?: Maybe<VerticalMediaOrientation>;
};

export type ChecklistStyle = {
  __typename?: 'ChecklistStyle';
  ctasOrientation?: Maybe<CtasOrientation>;
  height?: Maybe<Scalars['Int']>;
  hideCompletedSteps?: Maybe<Scalars['Boolean']>;
  hideStepGroupTitle?: Maybe<Scalars['Boolean']>;
  horizontalMediaAlignment?: Maybe<HorizontalMediaAlignment>;
  imageWidth?: Maybe<Scalars['String']>;
  mediaOrientation?: Maybe<MediaOrientation>;
  stepBodyOrientation?: Maybe<StepBodyOrientation>;
  verticalMediaAlignment?: Maybe<VerticalMediaAlignment>;
  verticalMediaOrientation?: Maybe<VerticalMediaOrientation>;
};

/** Account and account user targeting */
export type CommonTargeting = {
  __typename?: 'CommonTargeting';
  account: IntegrationTargetingSegment;
  accountUser: IntegrationTargetingSegment;
};

/** The position of the context tag relative to the tagged element */
export enum ContextualTagAlignmentEnumType {
  BottomLeft = 'bottom_left',
  BottomRight = 'bottom_right',
  CenterLeft = 'center_left',
  CenterRight = 'center_right',
  TopLeft = 'top_left',
  TopRight = 'top_right'
}

/** The position of the context tag's tooltip relative to the tag */
export enum ContextualTagTooltipAlignmentEnumType {
  Bottom = 'bottom',
  Left = 'left',
  Right = 'right',
  Top = 'top'
}

/** The style of the context tag */
export enum ContextualTagTypeEnumType {
  Badge = 'badge',
  BadgeDot = 'badge_dot',
  BadgeIcon = 'badge_icon',
  Dot = 'dot',
  Highlight = 'highlight',
  Icon = 'icon'
}

export type CreateTicketInput = {
  body: Scalars['String'];
  email: Scalars['String'];
  name: Scalars['String'];
  subject: Scalars['String'];
};

export type CreateTicketPayload = {
  __typename?: 'CreateTicketPayload';
  errors?: Maybe<Array<Scalars['String']>>;
  ticketId?: Maybe<Scalars['String']>;
};

export enum CtasOrientation {
  Inline = 'inline',
  Left = 'left',
  Right = 'right',
  SpaceBetween = 'spaceBetween'
}

/** The org cta styles */
export type CtasStyleStyleType = {
  __typename?: 'CtasStyleStyleType';
  borderRadius?: Maybe<Scalars['Int']>;
  fontSize?: Maybe<Scalars['Int']>;
  lineHeight?: Maybe<Scalars['Int']>;
  paddingX?: Maybe<Scalars['Int']>;
  paddingY?: Maybe<Scalars['Int']>;
};

/** Health status of a particular diagnostics category */
export enum DiagnosticStateEnum {
  Critical = 'critical',
  Healthy = 'healthy',
  NoData = 'noData',
  Warning = 'warning'
}

export type DismissNpsSurveyInput = {
  /** Entity ID of the NPS survey */
  entityId: Scalars['EntityId'];
};

export type DismissNpsSurveyPayload = {
  __typename?: 'DismissNpsSurveyPayload';
  errors?: Maybe<Array<Scalars['String']>>;
  npsSurvey?: Maybe<EmbedNpsSurvey>;
};

export type DropdownInputOption = {
  __typename?: 'DropdownInputOption';
  label?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** The variation for an input of type dropdown */
export enum DropdownInputVariationEnumType {
  Cards = 'cards',
  Dropdown = 'dropdown'
}

export type DropdownSettings = {
  __typename?: 'DropdownSettings';
  helperText?: Maybe<Scalars['String']>;
  multiSelect: Scalars['Boolean'];
  options: Array<DropdownInputOption>;
  required: Scalars['Boolean'];
  variation: DropdownInputVariationEnumType;
};

export type EmbedAccount = {
  __typename?: 'EmbedAccount';
  accountUsers: Array<AccountUser>;
  entityId: Scalars['EntityId'];
  /** The user-supplied unique ID for the Account */
  externalId?: Maybe<Scalars['String']>;
  /** The ID of an object */
  id: Scalars['ID'];
  /** The name of the account */
  name: Scalars['String'];
  ticketsEnabled: Scalars['Boolean'];
};

export type EmbedAccountUser = {
  __typename?: 'EmbedAccountUser';
  /** The account for whom this user belongs */
  account: EmbedAccount;
  createdInOrganizationAt?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  entityId: Scalars['EntityId'];
  externalId?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  fullName?: Maybe<Scalars['String']>;
  /** The ID of an object */
  id: Scalars['ID'];
};

export type EmbedAvailableGuides = {
  __typename?: 'EmbedAvailableGuides';
  guides: Array<Maybe<EmbedGuide>>;
};

export type EmbedBranch = {
  __typename?: 'EmbedBranch';
  key?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  selected: Scalars['Boolean'];
  /** Branching style based on the branching form factor */
  style?: Maybe<BranchingStyle>;
};

export type EmbedBranching = {
  __typename?: 'EmbedBranching';
  branches?: Maybe<Array<EmbedBranch>>;
  dismissDisabled: Scalars['Boolean'];
  formFactor?: Maybe<BranchingFormFactorEnumType>;
  key?: Maybe<Scalars['String']>;
  multiSelect: Scalars['Boolean'];
  question?: Maybe<Scalars['String']>;
  /** The type of target that is created by the action */
  type?: Maybe<BranchingPathEntityType>;
};

/** A guide displayed to an end user */
export type EmbedGuide = {
  __typename?: 'EmbedGuide';
  /** The account to which the guide belongs */
  account: EmbedAccount;
  /** Which branching choice key spawned this guide, if any */
  branchedFromChoice?: Maybe<EmbedGuideBranchedFromChoice>;
  /** Which branching guide spawned this guide, if any */
  branchedFromGuide?: Maybe<Scalars['EntityId']>;
  /** Determines if the guide should allow to reset onboarding */
  canResetOnboarding: Scalars['Boolean'];
  /** Time the guide was marked as completed */
  completedAt?: Maybe<Scalars['DateTime']>;
  /** The number of completed steps in the guide */
  completedStepsCount: Scalars['Int'];
  /** The completion state of the guide */
  completionState?: Maybe<GuideCompletionState>;
  /** A description of the guide */
  description?: Maybe<Scalars['String']>;
  /** The design type of the guide */
  designType: GuideDesignTypeEnumType;
  /** Time the guide was marked done */
  doneAt?: Maybe<Scalars['DateTime']>;
  entityId: Scalars['EntityId'];
  /** The first incomplete module for this guide */
  firstIncompleteModule?: Maybe<Scalars['EntityId']>;
  /** The first incomplete step for this guide */
  firstIncompleteStep?: Maybe<Scalars['EntityId']>;
  /** The form factor this guide is meant to display as. */
  formFactor?: Maybe<GuideFormFactorEnumType>;
  /** Style properties for this guides form factor */
  formFactorStyle?: Maybe<FormFactorStyle>;
  guideBase: EmbedGuideBase;
  /** The ID of an object */
  id: Scalars['ID'];
  /** The inline embed where this guide should be shown */
  inlineEmbed?: Maybe<EmbedOrganizationInlineEmbed>;
  /** Whether this guide is CYOA (single step guide that branches to another guide) */
  isCyoa: Scalars['Boolean'];
  /** Whether the user was added due to this guide being launched from another */
  isDestination: Scalars['Boolean'];
  /** Whether this guide is a side quest or a main quest. */
  isSideQuest?: Maybe<Scalars['Boolean']>;
  /** Whether the user is seeing the guide for the first time */
  isViewed: Scalars['Boolean'];
  /** The guide modules that belongs to the guide */
  modules: Array<EmbedGuideModule>;
  /** The name of the guide */
  name: Scalars['String'];
  /** Entity id of the guide after this one (only for main quest guides) */
  nextGuide?: Maybe<Scalars['EntityId']>;
  /** The order this guide is in the user's quests */
  orderIndex: Scalars['Int'];
  /** The type of page targeting mechanism */
  pageTargetingType: GuidePageTargetingEnumType;
  /** The URL for side quests page targeting, if enabled */
  pageTargetingUrl?: Maybe<Scalars['String']>;
  /** Entity id of the guide after this one (only for main quest guides) */
  previousGuide?: Maybe<Scalars['EntityId']>;
  /** Time the user saved the guide */
  savedAt?: Maybe<Scalars['DateTime']>;
  /** The current activeness state of the guide */
  state?: Maybe<GuideState>;
  /** The steps which belong to this guide */
  steps: Array<EmbedStep>;
  stepsByState: GuideStepsByState;
  /** Tagged elements which belong to this guide or any of its steps, in any order */
  taggedElements: Array<EmbedTaggedElement>;
  /** The theme for this guide */
  theme: ThemeType;
  /** The number of steps in the guide */
  totalSteps: Scalars['Int'];
  type: GuideTypeEnumType;
};

/** A guide base for a guide displayed to an end user */
export type EmbedGuideBase = {
  __typename?: 'EmbedGuideBase';
  entityId: Scalars['EntityId'];
  /** The name of the guide base */
  name: Scalars['String'];
};

export type EmbedGuideBranchedFromChoice = {
  __typename?: 'EmbedGuideBranchedFromChoice';
  branchingKey?: Maybe<Scalars['String']>;
  choiceKey?: Maybe<Scalars['String']>;
};

/** A module that exists within a guide */
export type EmbedGuideModule = {
  __typename?: 'EmbedGuideModule';
  /** The number of completed steps in the guide module */
  completedStepsCount: Scalars['Int'];
  entityId: Scalars['EntityId'];
  /** The first incomplete step in the module */
  firstIncompleteStep?: Maybe<Scalars['EntityId']>;
  /** The entityId of the guide this guide module belongs to */
  guide?: Maybe<Scalars['EntityId']>;
  /** The ID of an object */
  id: Scalars['ID'];
  /** Are all steps in this module completed */
  isComplete: Scalars['Boolean'];
  /** The name of the guide module */
  name: Scalars['String'];
  /** The next module entityId in the guide, if it exists */
  nextModule?: Maybe<Scalars['EntityId']>;
  /** The index of the guide module within the guide */
  orderIndex: Scalars['Int'];
  /** The previous module entityId in the guide, if it exists */
  previousModule?: Maybe<Scalars['EntityId']>;
  /** The steps belong to this guide module */
  steps: Array<EmbedStep>;
  /** The number of steps in the guide module */
  totalStepsCount: Scalars['Int'];
};

/** An input that belongs to a step */
export type EmbedInputStep = {
  __typename?: 'EmbedInputStep';
  /** The value answered for this input */
  answer?: Maybe<Scalars['String']>;
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** Label for the input */
  label: Scalars['String'];
  /** Index that indicates the order of the input */
  orderIndex: Scalars['Int'];
  /** Settings for the input according to its type */
  settings?: Maybe<InputSettings>;
  /** Type of the input */
  type: InputStepFieldTypeEnumType;
};

/** Net Promoter Score (NPS) survey */
export type EmbedNpsSurvey = {
  __typename?: 'EmbedNpsSurvey';
  /** Moment when this got answered */
  answeredAt?: Maybe<Scalars['DateTime']>;
  /** Moment when this got dismissed */
  dismissedAt?: Maybe<Scalars['DateTime']>;
  entityId: Scalars['EntityId'];
  /** Moment when this was seen for the first time */
  firstSeenAt?: Maybe<Scalars['DateTime']>;
  formFactor: NpsFormFactorEnumType;
  /** Presentation styles of the form factor */
  formFactorStyle: Scalars['JSON'];
  /**
   * Settings of the follow-up question
   * @deprecated Not implemented
   */
  fupSettings: Scalars['JSON'];
  /** Follow-up question-type */
  fupType: NpsFollowUpQuestionTypeEnumType;
  /** The ID of an object */
  id: Scalars['ID'];
  name: Scalars['String'];
  orderIndex: Scalars['Int'];
  /** Page targeting criteria of NPS survey */
  pageTargeting: EmbedNpsSurveyPageTargeting;
  /** Follow-up question */
  question: Scalars['String'];
};

/** Page targeting criteria of NPS survey */
export type EmbedNpsSurveyPageTargeting = {
  __typename?: 'EmbedNpsSurveyPageTargeting';
  /** Page targeting criteria */
  type: NpsPageTargetingTypeEnumType;
  /** Page targeting URL when targeting is set to a specific page */
  url?: Maybe<Scalars['String']>;
};

export type EmbedOrganization = {
  __typename?: 'EmbedOrganization';
  /** The domain of the organization */
  domain?: Maybe<Scalars['String']>;
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** The name of the organization */
  name: Scalars['String'];
  /** The unique slug identifying the organization */
  slug: Scalars['String'];
};

export type EmbedOrganizationInlineEmbed = {
  __typename?: 'EmbedOrganizationInlineEmbed';
  alignment?: Maybe<InlineEmbedAlignment>;
  borderRadius: Scalars['Int'];
  bottomMargin: Scalars['Int'];
  elementSelector: Scalars['String'];
  entityId: Scalars['EntityId'];
  /** The guide associated with this inline embed */
  guide?: Maybe<Scalars['EntityId']>;
  leftMargin: Scalars['Int'];
  maxWidth?: Maybe<Scalars['Int']>;
  padding: Scalars['Int'];
  position: InlineEmbedPosition;
  rightMargin: Scalars['Int'];
  state: InlineEmbedState;
  targeting: InlineEmbedTargeting;
  topMargin: Scalars['Int'];
  url: Scalars['String'];
  wildcardUrl: Scalars['String'];
};

export type EmbedOrganizationUiSettings = {
  __typename?: 'EmbedOrganizationUISettings';
  /** Additional branding colors of an org */
  additionalColors: Array<AdditionalColorsType>;
  allGuidesStyle: AllGuidesStyleType;
  /** The container's identifier of the organization's app */
  appContainerIdentifier?: Maybe<Scalars['String']>;
  /** The embeddable background color of this organization */
  backgroundColor?: Maybe<Scalars['String']>;
  /** The org banners styles */
  bannersStyle?: Maybe<BannersStyleStyleType>;
  /** The step separator borders and dividers color in HEX format */
  borderColor?: Maybe<Scalars['String']>;
  /** The background color of cards in the embeddable for this organization */
  cardBackgroundColor: Scalars['String'];
  /** The org cta styles */
  ctasStyle?: Maybe<CtasStyleStyleType>;
  /** The background hex color for CYOA guides */
  cyoaBackgroundColor?: Maybe<Scalars['String']>;
  /** The background hex color for CYOA guide cards */
  cyoaOptionBackgroundColor?: Maybe<Scalars['String']>;
  /** The border color of a CYOA card */
  cyoaOptionBorderColor: Scalars['String'];
  /** The shadow of a CYOA card */
  cyoaOptionShadow: Scalars['String'];
  /** The shadow of a CYOA card when hovered. */
  cyoaOptionShadowHover: Scalars['String'];
  /** The text hex color for CYOA guides */
  cyoaTextColor?: Maybe<Scalars['String']>;
  /** Custom CSS rules set by the organization */
  embedCustomCss?: Maybe<Scalars['String']>;
  /** Determines the behavior of the sidebar toggle when clicked */
  embedToggleBehavior: EmbedToggleBehaviorType;
  /** The offset in pixels for the X anchor of floating components */
  floatingAnchorXOffset: Scalars['Float'];
  /** The offset in pixels for the Y anchor of floating components */
  floatingAnchorYOffset: Scalars['Float'];
  /** The embeddable font color of this organization */
  fontColorHex?: Maybe<Scalars['String']>;
  /** Help center settings for the org */
  helpCenter?: Maybe<HelpCenter>;
  /** Help center styles for the org */
  helpCenterStyle: HelpCenterStyle;
  /** Whether the sidebar should be auto-injected on the customer's page */
  injectSidebar: Scalars['Boolean'];
  /** The Inline contextual style */
  inlineContextualStyle?: Maybe<InlineContextualStyleType>;
  /** Determines the inline component behaviour when no onboarding guides are available */
  inlineEmptyBehaviour: InlineEmptyBehaviourType;
  /** Whether the background color is dark */
  isBackgroundDark: Scalars['Boolean'];
  /** Whether the CYOA guide cards background color is dark */
  isCyoaOptionBackgroundColorDark: Scalars['Boolean'];
  /** Whether the toggles color is inverted of the organization */
  isEmbedToggleColorInverted?: Maybe<Scalars['Boolean']>;
  /** Whether the font color is dark */
  isFontColorDark: Scalars['Boolean'];
  /** Whether the secondary color is dark */
  isSecondaryColorDark: Scalars['Boolean'];
  /** If the viewer has not seen a guide before and the sidebar is present, is the auto-open functionality disabled */
  isSidebarAutoOpenOnFirstViewDisabled: Scalars['Boolean'];
  /** Whether the sidebar background color is dark */
  isSidebarBackgroundDark: Scalars['Boolean'];
  /** Whether (currently, Zendesk) kb search is enabled */
  kbSearchEnabled: Scalars['Boolean'];
  /** The org modals styles */
  modalsStyle?: Maybe<ModalsStyleStyleType>;
  /** The font size for step content in a guide */
  paragraphFontSize?: Maybe<Scalars['Float']>;
  /** The line height for step content in a guide */
  paragraphLineHeight?: Maybe<Scalars['Float']>;
  /** The primary brand color of this organization */
  primaryColorHex?: Maybe<Scalars['String']>;
  /** Quick links defined by the org */
  quickLinks: Array<Maybe<QuickLink>>;
  /** The responsive settings for the embed in narrow containers */
  responsiveVisibility?: Maybe<ResponsiveVisibilityType>;
  /** The secondary brand color of this organization */
  secondaryColorHex?: Maybe<Scalars['String']>;
  /** Determines if the sidebar is available to the user */
  sidebarAvailability: SidebarAvailabilityType;
  /** The sidebar background color of this organization */
  sidebarBackgroundColor: Scalars['String'];
  /** URLs where the sidebar component shoud not appear */
  sidebarBlocklistedUrls: Array<Maybe<Scalars['String']>>;
  /** The header settings for sidebars */
  sidebarHeader: GuideHeaderSettingsType;
  /** The sidebar side of the organization */
  sidebarSide?: Maybe<Scalars['String']>;
  /** The style of the sidebar */
  sidebarStyle?: Maybe<Scalars['String']>;
  /** Determines the sidebar visibility under specific conditions */
  sidebarVisibility: SidebarVisibilityType;
  /** Visual style of a completed step in the embeddable */
  stepCompletionStyle: Scalars['String'];
  /** The Step separation style */
  stepSeparationStyle?: Maybe<StepSeparationStyleType>;
  /** The border radius for badge and icon type tags */
  tagBadgeIconBorderRadius?: Maybe<Scalars['Float']>;
  /** The padding for badge and icon type tags */
  tagBadgeIconPadding?: Maybe<Scalars['Float']>;
  /** The custom icon URL for icon type tags */
  tagCustomIconUrl?: Maybe<Scalars['String']>;
  /** The size of dot type tags */
  tagDotSize?: Maybe<Scalars['Float']>;
  /** A brigther tone of the primary color for contextual tags */
  tagLightPrimaryColor?: Maybe<Scalars['String']>;
  /** The primary color for contextual tags */
  tagPrimaryColor?: Maybe<Scalars['String']>;
  /** The pulse level for dot type tags */
  tagPulseLevel?: Maybe<VisualTagPulseLevelType>;
  /** The text color for contextual tags */
  tagTextColor?: Maybe<Scalars['String']>;
  /** Determine the visibility behavior of visual tags */
  tagVisibility: TagVisibilityType;
  /** The guides themes for this organization */
  theme: ThemeType;
  /** If creating issues/tickets via integration is enabled */
  ticketCreationEnabled: Scalars['Boolean'];
  /** The color used for the sidebar toggle button in HEX format */
  toggleColorHex?: Maybe<Scalars['String']>;
  /** The toggle style of the organization */
  toggleStyle?: Maybe<Scalars['String']>;
  /** The toggle text of the organization */
  toggleText?: Maybe<Scalars['String']>;
  /** The color used for the sidebar text toggle button in HEX format */
  toggleTextColor: Scalars['String'];
  /** The org tooltips styles */
  tooltipsStyle?: Maybe<TooltipsStyleStyleType>;
  /** Whether Zendesk chat is enabled */
  zendeskChatEnabled: Scalars['Boolean'];
};

/** A step that exists within a guide */
export type EmbedStep = {
  __typename?: 'EmbedStep';
  /** The contents of the step */
  bodySlate?: Maybe<Scalars['JSON']>;
  /** The branching information of this Step */
  branching: EmbedBranching;
  /** When this step was completed */
  completedAt?: Maybe<Scalars['DateTime']>;
  /** The user who completed this step */
  completedByUser?: Maybe<AccountUser>;
  /** The CTAs of a step */
  ctas: Array<EmbedStepCta>;
  dismissLabel?: Maybe<Scalars['String']>;
  entityId: Scalars['EntityId'];
  /** The entityId of the guide that contains this step */
  guide: Scalars['EntityId'];
  /** If the user has viewed this step */
  hasViewedStep: Scalars['Boolean'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** The inputs of a step */
  inputs: Array<EmbedInputStep>;
  /** Whether the step has been marked as completed */
  isComplete: Scalars['Boolean'];
  /** Wether an auto complete step can be manually completed. */
  manualCompletionDisabled: Scalars['Boolean'];
  /** The media references associated to this step. */
  mediaReferences: Array<MediaReference>;
  /** The entityId of the module that contains this step */
  module: Scalars['EntityId'];
  /** The name of the step */
  name: Scalars['String'];
  /** The step that comes after */
  nextStepEntityId?: Maybe<Scalars['EntityId']>;
  /** The order index of the step within the guide */
  orderIndex: Scalars['Int'];
  /** The step entityId that comes before */
  previousStepEntityId?: Maybe<Scalars['EntityId']>;
  /** The state of the step */
  state: StepState;
  /** Optional, required, fyi, etc. */
  stepType: StepTypeEnum;
  /** Whether the step was completed automatically */
  wasCompletedAutomatically: Scalars['Boolean'];
};

export type EmbedStepAutoCompleteInteraction = {
  __typename?: 'EmbedStepAutoCompleteInteraction';
  elementSelector: Scalars['String'];
  entityId: Scalars['EntityId'];
  guide: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  step: Scalars['EntityId'];
  type: StepAutoCompleteInteractionTypeEnumType;
  url: Scalars['String'];
  wildcardUrl: Scalars['String'];
};

export type EmbedStepAutoCompleteInteractions = {
  __typename?: 'EmbedStepAutoCompleteInteractions';
  stepAutoCompleteInteractions: Array<Maybe<EmbedStepAutoCompleteInteraction>>;
};

export type EmbedStepCta = {
  __typename?: 'EmbedStepCta';
  /** The destination details for this cta, when of launch-type */
  destination?: Maybe<EmbedStepCtaDestination>;
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** The settings of the step CTA */
  settings?: Maybe<StepCtaSettingsType>;
  style: StepCtaStyleEnumType;
  text: Scalars['String'];
  type: StepCtaTypeEnumType;
  url?: Maybe<Scalars['String']>;
};

export type EmbedStepCtaDestination = {
  __typename?: 'EmbedStepCtaDestination';
  /** The design type of the destination guide */
  designType: GuideDesignTypeEnumType;
  /** The form factor this destination guide is meant to display as */
  formFactor?: Maybe<GuideFormFactorEnumType>;
  key: Scalars['String'];
  /** The page targeting details of the destination guide */
  pageTargeting: PageTargeting;
};

export type EmbedTaggedElement = {
  __typename?: 'EmbedTaggedElement';
  alignment: ContextualTagAlignmentEnumType;
  /** The design type for the related guide */
  designType: GuideDesignTypeEnumType;
  /** Date of tag dismissal, if any */
  dismissedAt?: Maybe<Scalars['DateTime']>;
  elementSelector: Scalars['String'];
  entityId: Scalars['EntityId'];
  /** The form factor for the related guide */
  formFactor: GuideFormFactorEnumType;
  guide: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  /**
   * Whether this visual tag is about a side quest or a main quest.
   * @deprecated use designType instead
   */
  isSideQuest: Scalars['Boolean'];
  relativeToText: Scalars['Boolean'];
  step?: Maybe<Scalars['EntityId']>;
  style?: Maybe<VisualTagStyleSettings>;
  tooltipAlignment: ContextualTagTooltipAlignmentEnumType;
  /** The title for the tooltip component */
  tooltipTitle: Scalars['String'];
  type: ContextualTagTypeEnumType;
  /** @deprecated use `wildcardUrl` instead */
  url: Scalars['String'];
  wildcardUrl: Scalars['String'];
  xOffset: Scalars['Int'];
  yOffset: Scalars['Int'];
};

/** The behavior of the sidebar toggle */
export enum EmbedToggleBehaviorType {
  Default = 'default',
  Persist = 'persist',
  ResourceCenter = 'resource_center'
}

/** Type of event to listen for */
export enum EventHookTypeEnum {
  All = 'all',
  GuideCompleted = 'guideCompleted',
  GuideViewed = 'guideViewed',
  Ping = 'ping',
  StepCompleted = 'stepCompleted',
  StepViewed = 'stepViewed'
}

/** A guide used in an customer account journey */
export type FileUpload = {
  __typename?: 'FileUpload';
  /** The account user that uploaded this file */
  accountUser?: Maybe<AccountUser>;
  createdAt: Scalars['DateTime'];
  entityId: Scalars['EntityId'];
  /** The name of the file */
  filename: Scalars['String'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** The original filename of the file */
  originalFilename: Scalars['String'];
  /** The account users that are participating in this guide */
  participants: Array<AccountUser>;
  /** The step in which this file was uploaded */
  step: Step;
  /** The url of the file */
  url?: Maybe<Scalars['String']>;
};

export type FormFactorStyle = BannerStyle | CardStyle | CarouselStyle | ChecklistStyle | ModalStyle | TooltipStyle | VideoGalleryStyle;

export type GetDestinationGuideInput = {
  ctaEntityId: Scalars['EntityId'];
  destinationKey: Scalars['EntityId'];
  /** Whether to mark the step as complete */
  markComplete: Scalars['Boolean'];
  stepEntityId: Scalars['EntityId'];
};

export type GetDestinationGuidePayload = {
  __typename?: 'GetDestinationGuidePayload';
  errors?: Maybe<Array<Scalars['String']>>;
  guide?: Maybe<EmbedGuide>;
  stepAutoCompleteInteractions: Array<EmbedStepAutoCompleteInteraction>;
};

/** A guide used in an customer account journey */
export type Guide = {
  __typename?: 'Guide';
  /** The account to which the guide belongs */
  account: Account;
  /** @deprecated use formFactor */
  allowedEmbedType?: Maybe<GuideAllowedEmbedTypeEnumType>;
  /** The timestamp of when the guide was completed */
  completedAt?: Maybe<Scalars['DateTime']>;
  /** The number of completed steps in the guide */
  completedStepsCount: Scalars['Int'];
  /** The percentage of steps completed in this guide */
  completionPercentage: Scalars['Int'];
  /** The completion state of the guide */
  completionState?: Maybe<GuideCompletionState>;
  createdFromGuideBase?: Maybe<GuideBase>;
  /** The entity ID of the template from which this guide was created */
  createdFromTemplate?: Maybe<Template>;
  /** A description of the guide */
  description?: Maybe<Scalars['String']>;
  /** The design type of the guide */
  designType: GuideDesignTypeEnumType;
  entityId: Scalars['EntityId'];
  /** The first incomplete step for this guide */
  firstIncompleteStep?: Maybe<Scalars['EntityId']>;
  /** The form factor this guide is meant to display as. */
  formFactor?: Maybe<GuideFormFactorEnumType>;
  /** Style properties for this guides form factor */
  formFactorStyle?: Maybe<FormFactorStyle>;
  /** The guide modules that belongs to the guide */
  guideModules: Array<GuideModule>;
  /** The ID of an object */
  id: Scalars['ID'];
  /** Whether this guide is CYOA (single step guide that branches to another guide) */
  isCyoa?: Maybe<Scalars['Boolean']>;
  /** Whether this guide is a side quest or a main quest. */
  isSideQuest?: Maybe<Scalars['Boolean']>;
  /** The timestamp of the last activity made on the guide */
  lastActiveAt?: Maybe<Scalars['DateTime']>;
  lastCompletedStep?: Maybe<Step>;
  /** The name of the guide */
  name: Scalars['String'];
  /** The type of page targeting mechanism */
  pageTargetingType: GuidePageTargetingEnumType;
  /** The URL for side quests page targeting, if enabled */
  pageTargetingUrl?: Maybe<Scalars['String']>;
  /** The account users that are participating in this guide */
  participants: Array<AccountUser>;
  /** The current activeness state of the guide */
  state: GuideState;
  /** The number of completed steps in the guide */
  stepsCount: Scalars['Int'];
  /** The theme for this guide */
  theme: ThemeType;
  type: GuideTypeEnumType;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

/** The embed type (e.g. inline or sidebar) the guide should be restricted to, if any. */
export enum GuideAllowedEmbedTypeEnumType {
  Inline = 'inline',
  Sidebar = 'sidebar'
}

/** A guide base from which guide instances can be created */
export type GuideBase = {
  __typename?: 'GuideBase';
  /** The account associated with the guide base */
  account: Account;
  /** The account-based onboarding guide created if the guide base is an "account" type */
  accountGuide?: Maybe<Guide>;
  /** When the guide base was activated/launched */
  activatedAt?: Maybe<Scalars['DateTime']>;
  /** The average completion percentage across all instances of this guide */
  averageCompletionPercentage: Scalars['Float'];
  averageStepsCompleted: Scalars['Int'];
  averageStepsViewed: Scalars['Int'];
  /** The entity ID of the template from which this guide base was created */
  createdFromTemplate?: Maybe<Template>;
  /**
   * CTA clicked information for announcement type guide bases, if available
   * @deprecated Use usersClickedCta instead
   */
  ctasClicked?: Maybe<Scalars['Int']>;
  /** A description of the guide base */
  description?: Maybe<Scalars['String']>;
  /** The design type of the guide */
  designType: GuideDesignTypeEnumType;
  entityId: Scalars['EntityId'];
  /**
   * The file uploads uploaded as part of this GuideBase
   * @deprecated Scheduled to be removed
   */
  fileUploads: Array<FileUpload>;
  /** The form factor this guide is meant to display as. */
  formFactor?: Maybe<GuideFormFactorEnumType>;
  /** Style properties for this guides form factor */
  formFactorStyle?: Maybe<FormFactorStyle>;
  /** The guide modules that belongs to the guide */
  guideModuleBases: Array<GuideModuleBase>;
  /** The guides created from the guide base */
  guides: Array<Guide>;
  /**
   * Does this guide base have any file uploads associated with it
   * @deprecated Scheduled to be removed
   */
  hasFileUploads: Scalars['Boolean'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** Whether this guide is CYOA (single step guide that branches to another guide) */
  isCyoa: Scalars['Boolean'];
  /** Wether the guide-base content was directly modified */
  isModifiedFromTemplate: Scalars['Boolean'];
  /** Whether this guide is a side quest or a main quest. */
  isSideQuest?: Maybe<Scalars['Boolean']>;
  /** Whether or not active split tests are targeting this template */
  isTargetedForSplitTesting: SplitTestStateEnumType;
  /** The last time the guide base was active by a user */
  lastActiveAt?: Maybe<Scalars['DateTime']>;
  /** The last completed step in any of the guides created from this guide base */
  lastCompletedStep?: Maybe<Step>;
  /** The name of the guide base */
  name?: Maybe<Scalars['String']>;
  /** When this guide base was made obsolete due to targeting no longer matching */
  obsoletedAt?: Maybe<Scalars['DateTime']>;
  /** The type of page targeting mechanism */
  pageTargetingType: GuidePageTargetingEnumType;
  /** The URL for side quests page targeting, if enabled */
  pageTargetingUrl?: Maybe<Scalars['String']>;
  /** The account users who have been assigned to a guide in the guide base */
  participants: Array<AccountUser>;
  /** The account users active in this guide */
  participantsCount: Scalars['Int'];
  /**
   * The account users active in this guide who have ALSO viewed the guide
   * @deprecated Same as usersViewedAStep
   */
  participantsWhoViewed: Array<AccountUser>;
  /** The count of participants in all instances of the guide base who have viewed the guide */
  participantsWhoViewedCount: Scalars['Int'];
  /** The current activeness state of the guide base */
  state: GuideBaseState;
  stepsCompletedCount: Scalars['Int'];
  /** The theme for this guide-base */
  theme: ThemeType;
  type: GuideTypeEnumType;
  /** Distinct users that clicked a CTA */
  usersClickedCta?: Maybe<Scalars['Int']>;
  /** Users who have completed a step within this guide base */
  usersCompletedAStep: Array<AccountUser>;
  usersCompletedAStepCount: Scalars['Int'];
  /** Users who have viewed a step within this guide base */
  usersViewedAStep: Array<AccountUser>;
  /** Whether the guide was auto-launched */
  wasAutoLaunched: Scalars['Boolean'];
};

/** The current activeness state of the guide */
export enum GuideBaseState {
  Active = 'active',
  Archived = 'archived',
  Draft = 'draft',
  Inactive = 'inactive',
  Obsoleted = 'obsoleted',
  Paused = 'paused'
}

export type GuideBaseStepAutoCompleteInteraction = {
  __typename?: 'GuideBaseStepAutoCompleteInteraction';
  elementSelector: Scalars['String'];
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  step: GuideStepBase;
  type: StepAutoCompleteInteractionTypeEnumType;
  url: Scalars['String'];
  wildcardUrl: Scalars['String'];
};

export type GuideBaseStepCta = {
  __typename?: 'GuideBaseStepCta';
  /** The step prototype CTA that this CTA comes from */
  createdFromStepPrototypeCta?: Maybe<StepPrototypeCta>;
  /** @deprecated Use destinationGuideObj */
  destinationGuide?: Maybe<Scalars['String']>;
  destinationGuideObj?: Maybe<Template>;
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** Index that indicates the order for ctas. */
  orderIndex: Scalars['Int'];
  /** The settings of the step CTA */
  settings?: Maybe<StepCtaSettingsType>;
  step: GuideStepBase;
  style: StepCtaStyleEnumType;
  text: Scalars['String'];
  type: StepCtaTypeEnumType;
  url?: Maybe<Scalars['String']>;
};

export type GuideBaseStepTaggedElement = {
  __typename?: 'GuideBaseStepTaggedElement';
  alignment: ContextualTagAlignmentEnumType;
  elementSelector: Scalars['String'];
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  relativeToText: Scalars['Boolean'];
  style?: Maybe<VisualTagStyleSettings>;
  tooltipAlignment: ContextualTagTooltipAlignmentEnumType;
  type: ContextualTagTypeEnumType;
  url: Scalars['String'];
  wildcardUrl: Scalars['String'];
  xOffset: Scalars['Int'];
  yOffset: Scalars['Int'];
};

/** The completion state of the guide */
export enum GuideCompletionState {
  Complete = 'complete',
  Done = 'done',
  Incomplete = 'incomplete'
}

/** The design type of this guide. */
export enum GuideDesignTypeEnumType {
  Announcement = 'announcement',
  Everboarding = 'everboarding',
  Onboarding = 'onboarding'
}

/** Criteria based on which to expire guides */
export enum GuideExpirationCriteria {
  Launch = 'launch',
  Never = 'never',
  StepCompletion = 'step_completion'
}

/** The form factor this guide is meant to display as. */
export enum GuideFormFactorEnumType {
  Banner = 'banner',
  Flow = 'flow',
  Inline = 'inline',
  InlineSidebar = 'inline_sidebar',
  Modal = 'modal',
  Sidebar = 'sidebar',
  Tooltip = 'tooltip'
}

/** Header close icon */
export enum GuideHeaderCloseIconType {
  DownArrow = 'downArrow',
  Minimize = 'minimize',
  X = 'x'
}

/** Header progress bar style */
export enum GuideHeaderProgressBarType {
  Continuous = 'continuous',
  Sections = 'sections'
}

/** Guide header settings */
export type GuideHeaderSettingsType = {
  __typename?: 'GuideHeaderSettingsType';
  closeIcon: GuideHeaderCloseIconType;
  progressBar?: Maybe<GuideHeaderProgressBarType>;
  showModuleNameInStepView: Scalars['Boolean'];
  type: GuideHeaderStyleType;
};

/** Header base style */
export enum GuideHeaderStyleType {
  Bright = 'bright',
  Classic = 'classic',
  Simple = 'simple',
  Striped = 'striped'
}

/** A module that exists within a guide */
export type GuideModule = {
  __typename?: 'GuideModule';
  /** The module from which this guide module was created */
  createdFromModule?: Maybe<Module>;
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  /**
   * The name of the guide module
   * @deprecated Use `name` from `GuideModuleBase` instead
   */
  name: Scalars['String'];
  /** The index of the guide module within the guide */
  orderIndex: Scalars['Int'];
  /** The steps belong to this guide module */
  steps: Array<Step>;
};

/** A module that exists within a guide base */
export type GuideModuleBase = {
  __typename?: 'GuideModuleBase';
  /** When was the guide module base dynamically added */
  addedDynamicallyAt?: Maybe<Scalars['DateTime']>;
  /** The module from which this guide module was created */
  createdFromModule?: Maybe<Module>;
  /** The step that dynamically added this guide module base */
  dynamicallyAddedByStep?: Maybe<Step>;
  entityId: Scalars['EntityId'];
  /** The step bases belong to this guide module base */
  guideStepBases: Array<GuideStepBase>;
  hasBranchingStep?: Maybe<Scalars['Boolean']>;
  hasInputStep?: Maybe<Scalars['Boolean']>;
  /** The ID of an object */
  id: Scalars['ID'];
  /** The name of the guide module base */
  name: Scalars['String'];
  /** The index of the guide module within the guide */
  orderIndex: Scalars['Int'];
  /** The account users who have been assigned to a guide module in the guide module base */
  participants: Array<AccountUser>;
  /** The count of account users who have been assigned to a guide module in the guide module base */
  participantsCount: Scalars['Int'];
  /** The account users active in this guide module who have ALSO viewed the guide module */
  participantsWhoViewed: Array<AccountUser>;
  /** The count of participants in all instances of the guide module base who have viewed the guide module */
  participantsWhoViewedCount: Scalars['Int'];
  /** Whether the guide module base should be added to a guide dynamically or not */
  shouldOnlyAddToNewGuidesDynamically: Scalars['Boolean'];
};

/** The type of page targeting mechanism */
export enum GuidePageTargetingEnumType {
  AnyPage = 'any_page',
  Inline = 'inline',
  SpecificPage = 'specific_page',
  VisualTag = 'visual_tag'
}

/** The current activeness state of the guide */
export enum GuideState {
  Active = 'active',
  Draft = 'draft',
  Expired = 'expired',
  Inactive = 'inactive'
}

/** A step that exists within a guide base */
export type GuideStepBase = {
  __typename?: 'GuideStepBase';
  /** The auto complete interaction of a step */
  autoCompleteInteraction?: Maybe<GuideBaseStepAutoCompleteInteraction>;
  /** The descriptive text of the step */
  body?: Maybe<Scalars['String']>;
  /** The Slate.JS RTE representation of the Step body */
  bodySlate?: Maybe<Scalars['JSON']>;
  branchingChoices?: Maybe<Array<BranchingChoice>>;
  branchingDismissDisabled?: Maybe<Scalars['Boolean']>;
  branchingFormFactor?: Maybe<BranchingFormFactorEnumType>;
  branchingKey?: Maybe<Scalars['String']>;
  branchingMultiple?: Maybe<Scalars['Boolean']>;
  branchingPaths?: Maybe<Array<BranchingPath>>;
  branchingQuestion?: Maybe<Scalars['String']>;
  /** The number of account users who have viewed this guide step base */
  countUsersViewed: Scalars['Int'];
  /** The step prototype that this guide step base comes from */
  createdFromStepPrototype?: Maybe<StepPrototype>;
  /** The CTAs of a step */
  ctas: Array<GuideBaseStepCta>;
  dismissLabel?: Maybe<Scalars['String']>;
  entityId: Scalars['EntityId'];
  /** Files that have been uploaded in steps created from this guide step base */
  fileUploads: Array<FileUpload>;
  /** Does the guide step base have any file uploads */
  hasFileUploads: Scalars['Boolean'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** The input prototypes of a step */
  inputs: Array<InputStepBase>;
  /** Can the step be completed via auto completion */
  isAutoCompletable: Scalars['Boolean'];
  /** Wether an auto complete step can be manually completed. */
  manualCompletionDisabled: Scalars['Boolean'];
  /** The media references associated to this step. */
  mediaReferences: Array<MediaReference>;
  /** The name of the step */
  name: Scalars['String'];
  orderIndex: Scalars['Int'];
  /** The percentage of users who have completed the guide step base */
  percentageCompleted: Scalars['Float'];
  /** Whether or not step is required, optional, fyi, etc... */
  stepType: StepTypeEnum;
  /**
   * The step instances that were created from this guide step base
   * @deprecated Should not be used due to performance concerns. Is likely to be removed.
   */
  steps: Array<Step>;
  taggedElements: Array<GuideBaseStepTaggedElement>;
  updatedAt: Scalars['DateTime'];
  /** A list of account users who completed this guide step base */
  usersCompleted: Array<AccountUser>;
  /** A list of account users who viewed this guide step base */
  usersViewed: Array<AccountUser>;
};

export type GuideStepsByState = {
  __typename?: 'GuideStepsByState';
  complete?: Maybe<Array<Maybe<EmbedStep>>>;
  incomplete?: Maybe<Array<Maybe<EmbedStep>>>;
  skipped?: Maybe<Array<Maybe<EmbedStep>>>;
  viewed?: Maybe<Array<Maybe<EmbedStep>>>;
};

/** The scope of the created guide template */
export enum GuideTypeEnumType {
  Account = 'account',
  SplitTest = 'split_test',
  Template = 'template',
  User = 'user'
}

export type HelpCenter = {
  __typename?: 'HelpCenter';
  issueSubmission?: Maybe<Scalars['Boolean']>;
  kbSearch?: Maybe<Scalars['Boolean']>;
  liveChat?: Maybe<Scalars['Boolean']>;
  source: HelpCenterSource;
  targeting?: Maybe<CommonTargeting>;
  url?: Maybe<Scalars['String']>;
};

/** The help center used by the org */
export enum HelpCenterSource {
  Helpscout = 'helpscout',
  Intercom = 'intercom',
  Salesforce = 'salesforce',
  Zendesk = 'zendesk'
}

export type HelpCenterStyle = {
  __typename?: 'HelpCenterStyle';
  chatTitle?: Maybe<Scalars['String']>;
  supportTicketTitle?: Maybe<Scalars['String']>;
};

export enum HorizontalMediaAlignment {
  Center = 'center',
  Left = 'left',
  Right = 'right'
}

export type ImageMediaMeta = {
  __typename?: 'ImageMediaMeta';
  naturalHeight?: Maybe<Scalars['Int']>;
  naturalWidth?: Maybe<Scalars['Int']>;
};

export type ImageMediaReferenceSettings = {
  __typename?: 'ImageMediaReferenceSettings';
  alignment?: Maybe<Scalars['String']>;
  fill?: Maybe<Scalars['String']>;
  hyperlink?: Maybe<Scalars['String']>;
  lightboxDisabled?: Maybe<Scalars['Boolean']>;
};

/** The Inline contextual style */
export type InlineContextualStyleType = {
  __typename?: 'InlineContextualStyleType';
  borderColor?: Maybe<Scalars['String']>;
  borderRadius: Scalars['Int'];
  padding: Scalars['Int'];
  shadow: InlineContextualType;
};

/** The box shadow for inline contextual guides */
export enum InlineContextualType {
  None = 'none',
  Standard = 'standard'
}

/** Alignment of the injected inline */
export enum InlineEmbedAlignment {
  Center = 'center',
  Left = 'left',
  Right = 'right'
}

/** The position where the inline should be injected relative to the selected element */
export enum InlineEmbedPosition {
  After = 'after',
  Before = 'before',
  Inside = 'inside'
}

/** The launched state of the inline embed */
export enum InlineEmbedState {
  Active = 'active',
  Inactive = 'inactive'
}

/** Account and account user targeting for inline embeds */
export type InlineEmbedTargeting = {
  __typename?: 'InlineEmbedTargeting';
  account: InlineEmbedTargetingSegment;
  accountUser: InlineEmbedTargetingSegment;
};

/** An inline embed targeting attribute rule */
export type InlineEmbedTargetingRule = {
  __typename?: 'InlineEmbedTargetingRule';
  attribute: Scalars['String'];
  ruleType: TargetAttributeRuleRuleTypeEnumType;
  value: Scalars['TargetAttributeRuleFields'];
  valueType: AttributeValueType;
};

/** Inline embed targeting segment */
export type InlineEmbedTargetingSegment = {
  __typename?: 'InlineEmbedTargetingSegment';
  grouping?: Maybe<Scalars['String']>;
  rules?: Maybe<Array<Maybe<InlineEmbedTargetingRule>>>;
  type: InlineEmbedTargetingType;
};

/** The rule type of rules for an inline embed */
export enum InlineEmbedTargetingType {
  All = 'all',
  AttributeRules = 'attribute_rules',
  Role = 'role'
}

/** The inline behaviour when no onboarding guides are available */
export enum InlineEmptyBehaviourType {
  Hide = 'hide',
  Show = 'show'
}

export type InputFieldAnswerInput = {
  answer?: InputMaybe<Scalars['String']>;
  entityId: Scalars['EntityId'];
};

export type InputSettings = DropdownSettings | NpsSettings | NumberPollSettings | TextOrEmailSettings;

/** An input base that belongs to a guide step base */
export type InputStepBase = {
  __typename?: 'InputStepBase';
  entityId: Scalars['EntityId'];
  /** The guide step base to which this input base belongs to */
  guideStepBase: GuideStepBase;
  /** The ID of an object */
  id: Scalars['ID'];
  /** Label for the input */
  label: Scalars['String'];
  /** Index that indicates the order of the input */
  orderIndex: Scalars['Int'];
  /** Settings for the input according to its type */
  settings?: Maybe<InputSettings>;
  /** Type of the input */
  type: InputStepFieldTypeEnumType;
};

/** The type of the input prototype */
export enum InputStepFieldTypeEnumType {
  Date = 'date',
  Dropdown = 'dropdown',
  Email = 'email',
  Nps = 'nps',
  NumberPoll = 'numberPoll',
  Paragraph = 'paragraph',
  Text = 'text'
}

/** An input prototype that belongs to a step prototype */
export type InputStepPrototype = {
  __typename?: 'InputStepPrototype';
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** Label for the input */
  label: Scalars['String'];
  /** Index that indicates the order of the input */
  orderIndex: Scalars['Int'];
  /** Settings for the input according to its type */
  settings?: Maybe<InputSettings>;
  /** The step prototype to which this input prototype belongs to */
  stepPrototype: StepPrototype;
  /** Type of the input */
  type: InputStepFieldTypeEnumType;
};

export type IntegrationApiKey = {
  __typename?: 'IntegrationApiKey';
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** The time of first successful integration */
  integratedAt?: Maybe<Scalars['DateTime']>;
  issueSubmission?: Maybe<Scalars['Boolean']>;
  kbSearch?: Maybe<Scalars['Boolean']>;
  /** The API key for the organization to connect to the integration */
  key: Scalars['String'];
  /** For scheduled integrations, last time it ran automatically */
  lastRunAt?: Maybe<Scalars['DateTime']>;
  /** The organization that the Segment API key belongs to */
  organization: Organization;
  state: IntegrationStateEnum;
  /**
   * If this particular integration specifically should be targeted to certain segments
   * @deprecated Not in use, to potentially be revisited later.
   */
  targeting: TargetsType;
  /** @deprecated We should no longer store two states in one key */
  twoWayState?: Maybe<TwoWayState>;
  type?: Maybe<IntegrationTypeEnum>;
  zendeskState?: Maybe<ZendeskState>;
};

export enum IntegrationStateEnum {
  Active = 'active',
  Inactive = 'inactive'
}

/** An integration targeting attribute rule */
export type IntegrationTargetingRule = {
  __typename?: 'IntegrationTargetingRule';
  attribute: Scalars['String'];
  ruleType: TargetAttributeRuleRuleTypeEnumType;
  value: Scalars['TargetAttributeRuleFields'];
  valueType: AttributeValueType;
};

/** Integration targeting segment */
export type IntegrationTargetingSegment = {
  __typename?: 'IntegrationTargetingSegment';
  grouping?: Maybe<Scalars['String']>;
  rules?: Maybe<Array<Maybe<IntegrationTargetingRule>>>;
  type: IntegrationTargetingType;
};

/** The rule type of rules for an integration */
export enum IntegrationTargetingType {
  All = 'all',
  AttributeRules = 'attribute_rules',
  Role = 'role'
}

/** What integration this key is for */
export enum IntegrationTypeEnum {
  Zendesk = 'zendesk'
}

export type Media = {
  __typename?: 'Media';
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  meta: MediaMetaType;
  type: MediaTypeEnumType;
  url: Scalars['String'];
};

/** The media reference settings */
export type MediaMetaType = ImageMediaMeta | NumberAttributeMediaMeta | VideoMediaMeta;

export enum MediaOrientation {
  Left = 'left',
  Right = 'right'
}

export type MediaReference = {
  __typename?: 'MediaReference';
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** The media associated to this record. */
  media: Media;
  mediaId: Scalars['Int'];
  orderIndex: Scalars['Int'];
  referenceId: Scalars['Int'];
  referenceType: MediaReferenceTypeEnumType;
  settings: MediaReferenceSettingsType;
};

/** The media reference settings */
export type MediaReferenceSettingsType = ImageMediaReferenceSettings | NumberAttributeMediaReferenceSettings | VideoMediaReferenceSettings;

/** The type of a media reference */
export enum MediaReferenceTypeEnumType {
  StepPrototype = 'step_prototype'
}

/** The type of a media element */
export enum MediaTypeEnumType {
  Image = 'image',
  NumberAttribute = 'number_attribute',
  Video = 'video'
}

export enum ModalPosition {
  BottomLeft = 'bottom_left',
  BottomRight = 'bottom_right',
  Center = 'center',
  TopLeft = 'top_left',
  TopRight = 'top_right'
}

export enum ModalSize {
  Large = 'large',
  Medium = 'medium',
  Small = 'small'
}

export type ModalStyle = {
  __typename?: 'ModalStyle';
  backgroundColor?: Maybe<Scalars['String']>;
  canDismiss?: Maybe<Scalars['Boolean']>;
  ctasOrientation?: Maybe<CtasOrientation>;
  hasBackgroundOverlay: Scalars['Boolean'];
  height?: Maybe<Scalars['Int']>;
  horizontalMediaAlignment?: Maybe<HorizontalMediaAlignment>;
  imageWidth?: Maybe<Scalars['String']>;
  mediaFontSize?: Maybe<Scalars['Int']>;
  mediaOrientation?: Maybe<MediaOrientation>;
  mediaTextColor?: Maybe<Scalars['String']>;
  modalSize: ModalSize;
  position: ModalPosition;
  stepBodyOrientation?: Maybe<StepBodyOrientation>;
  textColor?: Maybe<Scalars['String']>;
  verticalMediaAlignment?: Maybe<VerticalMediaAlignment>;
  verticalMediaOrientation?: Maybe<VerticalMediaOrientation>;
};

/** The org modals styles */
export type ModalsStyleStyleType = {
  __typename?: 'ModalsStyleStyleType';
  backgroundOverlayColor?: Maybe<Scalars['String']>;
  backgroundOverlayOpacity?: Maybe<Scalars['Int']>;
  borderRadius?: Maybe<Scalars['Int']>;
  paddingX?: Maybe<Scalars['Int']>;
  paddingY?: Maybe<Scalars['Int']>;
  shadow?: Maybe<AnnouncementShadowType>;
};

/** A standalone module of steps */
export type Module = {
  __typename?: 'Module';
  /** The description of the module */
  description?: Maybe<Scalars['String']>;
  /**
   * The title displayed in the guides created from the module.
   * @deprecated Use `name` instead
   */
  displayTitle?: Maybe<Scalars['String']>;
  /** The templates in which this module is added to dynamically */
  dynamicTemplates: Array<Template>;
  entityId: Scalars['EntityId'];
  hasBranchingStep?: Maybe<Scalars['Boolean']>;
  hasInputStep?: Maybe<Scalars['Boolean']>;
  /** The ID of an object */
  id: Scalars['ID'];
  /** Whether this step group is CYOA */
  isCyoa?: Maybe<Scalars['Boolean']>;
  /** If this module is appended dynamically to anything */
  isDynamic?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the module is empty based on step body content */
  isEmpty: Scalars['Boolean'];
  lastEdited?: Maybe<TemplateLastEdited>;
  /** When was the module was last used */
  lastUsedAt?: Maybe<Scalars['DateTime']>;
  /** The name of the module */
  name?: Maybe<Scalars['String']>;
  /** The number of accounts with unmodified guides created from this template */
  numberOfAccountsWithUnmodifiedGuides: Scalars['Int'];
  /** How many guides this will eventually touch */
  propagationCount: Scalars['Int'];
  /** Number of pending propagation jobs as a result of saving */
  propagationQueue: Scalars['Int'];
  /** The step prototypes included as part of this module */
  stepPrototypes: Array<StepPrototype>;
  /** Rules for dynamic module targeting */
  targetingData: Array<ModuleTargetingData>;
  /** The templates in which this module is being used */
  templates: Array<Template>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

/** An autolaunch rule for a module */
export type ModuleAutoLaunchRule = {
  __typename?: 'ModuleAutoLaunchRule';
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  module: Module;
  /** What type of rule is the auto launch rule */
  ruleType: ModuleRuleType;
  /** The account user targeting rules, if the targetType is "attributeRules" */
  rules: Array<Scalars['JSON']>;
};

export enum ModuleRuleType {
  AttributeRules = 'attribute_rules'
}

export type ModuleTargetingData = {
  __typename?: 'ModuleTargetingData';
  autoLaunchRules: Array<ModuleAutoLaunchRule>;
  /** EntityId of the targeted template */
  targetTemplate: Scalars['String'];
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Record the answer given by the end-user to a NPS Survey */
  answerNpsSurvey?: Maybe<AnswerNpsSurveyPayload>;
  /** Submits a support ticket */
  createTicket?: Maybe<CreateTicketPayload>;
  /** Record an NPS Survey as dimissed by the end-user */
  dismissNpsSurvey?: Maybe<DismissNpsSurveyPayload>;
  /** Launch and return the destination guide to the user */
  getDestinationGuide?: Maybe<GetDestinationGuidePayload>;
  /** Record tag dismissed */
  recordTagDismissed?: Maybe<RecordTagDismissedPayload>;
  /** Reset branching guides for account user */
  resetOnboarding?: Maybe<ResetOnboardingPayload>;
  /** Save the given guide so the account user can get back to it later */
  saveGuideForLater?: Maybe<SaveGuideForLaterPayload>;
  /** set attributes on a user or account */
  selectBranchingPath?: Maybe<SelectBranchingPathPayload>;
  /** Set step auto completion by interaction */
  setStepAutoCompletion?: Maybe<SetStepAutoCompletionPayload>;
  /** Set step completion */
  setStepCompletion?: Maybe<SetStepCompletionPayload>;
  /** Set step skipped */
  setStepSkipped?: Maybe<SetStepSkippedPayload>;
  /** Registers a CTA as clicked without any other action */
  trackCtaClicked?: Maybe<TrackCtaClickedPayload>;
  /** Track guide view start/end */
  trackGuideView?: Maybe<TrackGuideViewPayload>;
  /** Track the NPS Survey as viewed by the end-user. Can be called multiple times but will only have an effect the first time. */
  trackNpsSurveyViewed?: Maybe<TrackNpsSurveyViewedPayload>;
  /** Track step view start/end */
  trackStepView?: Maybe<TrackStepViewPayload>;
};


export type MutationAnswerNpsSurveyArgs = {
  input: AnswerNpsSurveyInput;
};


export type MutationCreateTicketArgs = {
  input: CreateTicketInput;
};


export type MutationDismissNpsSurveyArgs = {
  input: DismissNpsSurveyInput;
};


export type MutationGetDestinationGuideArgs = {
  input: GetDestinationGuideInput;
};


export type MutationRecordTagDismissedArgs = {
  input: RecordTagDismissedInput;
};


export type MutationResetOnboardingArgs = {
  input: ResetOnboardingInput;
};


export type MutationSaveGuideForLaterArgs = {
  input: SaveGuideForLaterInput;
};


export type MutationSelectBranchingPathArgs = {
  input: SelectBranchingPathInput;
};


export type MutationSetStepAutoCompletionArgs = {
  input: SetStepAutoCompletionInput;
};


export type MutationSetStepCompletionArgs = {
  input: SetStepCompletionInput;
};


export type MutationSetStepSkippedArgs = {
  input: SetStepSkippedInput;
};


export type MutationTrackCtaClickedArgs = {
  input: TrackCtaClickedInput;
};


export type MutationTrackGuideViewArgs = {
  input: TrackGuideViewInput;
};


export type MutationTrackNpsSurveyViewedArgs = {
  input: TrackNpsSurveyViewedInput;
};


export type MutationTrackStepViewArgs = {
  input: TrackStepViewInput;
};

/** Follow-up question-type of NPS survey */
export enum NpsFollowUpQuestionTypeEnumType {
  None = 'none',
  ScoreBased = 'score_based',
  Universal = 'universal'
}

/** Form factor of NPS survey */
export enum NpsFormFactorEnumType {
  Banner = 'banner'
}

/** Page targeting type of NPS survey */
export enum NpsPageTargetingTypeEnumType {
  AnyPage = 'any_page',
  SpecificPage = 'specific_page'
}

export type NpsSettings = {
  __typename?: 'NpsSettings';
  helperText?: Maybe<Scalars['String']>;
  /** @deprecated Value is not editable */
  maxLabel?: Maybe<Scalars['String']>;
  /** @deprecated Value is not editable */
  maxValue?: Maybe<Scalars['Int']>;
  /** @deprecated Value is not editable */
  minLabel?: Maybe<Scalars['String']>;
  /** @deprecated Value is not editable */
  minValue?: Maybe<Scalars['Int']>;
  required: Scalars['Boolean'];
};

export type NumberAttributeMediaMeta = {
  __typename?: 'NumberAttributeMediaMeta';
  _?: Maybe<Scalars['Boolean']>;
};

export type NumberAttributeMediaReferenceSettings = {
  __typename?: 'NumberAttributeMediaReferenceSettings';
  _?: Maybe<Scalars['Boolean']>;
};

export type NumberPollSettings = {
  __typename?: 'NumberPollSettings';
  helperText?: Maybe<Scalars['String']>;
  maxLabel?: Maybe<Scalars['String']>;
  maxValue?: Maybe<Scalars['Int']>;
  minLabel?: Maybe<Scalars['String']>;
  minValue?: Maybe<Scalars['Int']>;
  required: Scalars['Boolean'];
};

export type OnGuideCompletion = {
  __typename?: 'OnGuideCompletion';
  interactionType?: Maybe<AutoCompleteInteractionType>;
  templateEntityId: Scalars['String'];
};

export type OrgDiagnostics = {
  __typename?: 'OrgDiagnostics';
  /** There is only one account, indicating possible hard-coding */
  hardCodedAccounts?: Maybe<DiagnosticStateEnum>;
  /** There is only one user, indicating possible hard-coding */
  hardCodedUsers?: Maybe<DiagnosticStateEnum>;
  /** Account users have recommended base attributes */
  hasRecommendedAttributes?: Maybe<DiagnosticStateEnum>;
  /** Attributes change data type */
  inconsistentTypes?: Maybe<DiagnosticStateEnum>;
  /** Dates are passed in non-ISO format */
  nonIsoDates?: Maybe<DiagnosticStateEnum>;
  /** If we have received a ping from their snippet */
  successfulInitialization?: Maybe<DiagnosticStateEnum>;
  /** Account user ids do not look like hard-coded emails */
  validAccountUserIds?: Maybe<DiagnosticStateEnum>;
};

/** Level of service this org is paying for */
export enum OrgPlan {
  Custom = 'Custom',
  Growth = 'Growth',
  Scale = 'Scale',
  Starter = 'Starter'
}

export type Organization = {
  __typename?: 'Organization';
  /** The accounts belonging to the organization */
  accounts: Array<Account>;
  /** The accounts count within the organization */
  accountsCount: Scalars['Float'];
  /** [TEMP] The guide that is currently active this organization in a Chrome extension */
  activeGuide?: Maybe<Guide>;
  allottedGuides?: Maybe<Scalars['Int']>;
  /** Indicates whether any of the given list of entities are currently being reset */
  areEntitiesResetting?: Maybe<Scalars['Boolean']>;
  /** For use with Bento native API */
  bentoApiKey?: Maybe<SegmentApiKey>;
  /** The branching questions in the organization */
  branchingQuestions: Array<BranchingQuestion>;
  /** If we need to limit the ability to consecutively propagate */
  controlSyncing?: Maybe<Scalars['Boolean']>;
  createdAt: Scalars['DateTime'];
  /** Diagnostics for an org. Must specify keys to load data */
  diagnostics?: Maybe<OrgDiagnostics>;
  /** The domain of the organization */
  domain?: Maybe<Scalars['String']>;
  /** Features enabled for this organization */
  enabledFeatureFlags: Array<Scalars['String']>;
  entityId: Scalars['EntityId'];
  /** Determine if the org domain has Google SSO enabled. */
  googleSSOEnabled: Scalars['Boolean'];
  /** The count of guide bases that have been viewed within the organization */
  guideBaseCount: Scalars['Int'];
  hasAccountUsers?: Maybe<Scalars['Boolean']>;
  hasAudiences?: Maybe<Scalars['Boolean']>;
  /** Check all cached diagnostic states without specifying keys */
  hasDiagnosticWarnings: Scalars['Boolean'];
  /** A list of integrations the org has */
  hasIntegrations?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Whether or not the org has launched a guide base. */
  hasLaunchedGuides?: Maybe<Scalars['Boolean']>;
  hostnames: Array<Scalars['String']>;
  /** The ID of an object */
  id: Scalars['ID'];
  inlineEmbeds?: Maybe<Array<Maybe<OrganizationInlineEmbed>>>;
  /** The name of the organization */
  name: Scalars['String'];
  plan: OrgPlan;
  /** The unique slug identifying the organization */
  slug: Scalars['String'];
  /** The current state of the org as a bento customer */
  state: OrganizationStateEnumType;
  taggedElementUrls: Array<Scalars['String']>;
  /** The templates within the organization */
  templates: Array<Template>;
  /** The templates count within the organization */
  templatesCount: Scalars['Float'];
  trialEndedAt?: Maybe<Scalars['DateTime']>;
  trialStartedAt?: Maybe<Scalars['DateTime']>;
  /** The users in the organization */
  users: Array<User>;
  /** Retrieves a default URL for the visual builder entry page */
  visualBuilderDefaultUrl?: Maybe<Scalars['String']>;
};


export type OrganizationAreEntitiesResettingArgs = {
  entityIds: Array<Scalars['EntityId']>;
  resetLevel: ResetLevelEnumType;
};

export type OrganizationInlineEmbed = {
  __typename?: 'OrganizationInlineEmbed';
  alignment?: Maybe<InlineEmbedAlignment>;
  borderRadius: Scalars['Int'];
  bottomMargin: Scalars['Int'];
  elementSelector: Scalars['String'];
  entityId: Scalars['EntityId'];
  leftMargin: Scalars['Int'];
  maxWidth?: Maybe<Scalars['Int']>;
  padding: Scalars['Int'];
  position: InlineEmbedPosition;
  rightMargin: Scalars['Int'];
  state: InlineEmbedState;
  targeting: InlineEmbedTargeting;
  /** The template associated with this inline embed */
  template?: Maybe<Template>;
  topMargin: Scalars['Int'];
  url: Scalars['String'];
  wildcardUrl: Scalars['String'];
};

/** General organization-wide settings */
export type OrganizationOrgSettings = {
  __typename?: 'OrganizationOrgSettings';
  bentoApiKey?: Maybe<SegmentApiKey>;
  /** Default URL for linking to guide participants for nudges and other emails */
  defaultUserNotificationURL?: Maybe<Scalars['String']>;
  /** Default email address for notifications */
  fallbackCommentsEmail?: Maybe<Scalars['String']>;
  integrationApiKeys?: Maybe<Array<IntegrationApiKey>>;
  /** Are guide participant email nudges enabled */
  sendAccountUserNudges?: Maybe<Scalars['Boolean']>;
  /** Are guide notification settings enabled */
  sendEmailNotifications?: Maybe<Scalars['Boolean']>;
  webhooks?: Maybe<Array<Webhook>>;
};

/** The current state of the org as a bento customer */
export enum OrganizationStateEnumType {
  Active = 'active',
  Inactive = 'inactive',
  Trial = 'trial'
}

export type PageTargeting = {
  __typename?: 'PageTargeting';
  /** The type of page targeting mechanism */
  type: GuidePageTargetingEnumType;
  /** The URL for side quests page targeting, if enabled */
  url?: Maybe<Scalars['String']>;
};

export type QuickLink = {
  __typename?: 'QuickLink';
  icon?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  url: Scalars['String'];
};

export type RecordTagDismissedInput = {
  tagEntityId: Scalars['EntityId'];
};

export type RecordTagDismissedPayload = {
  __typename?: 'RecordTagDismissedPayload';
  errors?: Maybe<Array<Scalars['String']>>;
  tag?: Maybe<EmbedTaggedElement>;
};

/** Level at which guide reset applies */
export enum ResetLevelEnumType {
  Account = 'account',
  GuideBase = 'guide_base',
  Template = 'template'
}

export type ResetOnboardingInput = {
  guideEntityId: Scalars['EntityId'];
};

export type ResetOnboardingPayload = {
  __typename?: 'ResetOnboardingPayload';
  accountUser?: Maybe<EmbedAccountUser>;
  errors?: Maybe<Array<Scalars['String']>>;
};

export enum ResponsiveVisibilityBehaviorType {
  Hide = 'hide',
  Show = 'show'
}

/** The responsive settings for the embed in narrow containers */
export type ResponsiveVisibilityType = {
  __typename?: 'ResponsiveVisibilityType';
  all: ResponsiveVisibilityBehaviorType;
};

export type RootType = {
  __typename?: 'RootType';
  account: EmbedAccount;
  accountUser: EmbedAccountUser;
  /** Guides available to the user */
  availableGuides: Array<Maybe<EmbedGuide>>;
  guide?: Maybe<EmbedGuide>;
  inlineEmbeds?: Maybe<Array<Maybe<EmbedOrganizationInlineEmbed>>>;
  /** Fetch an incomplete NPS survey, currently available to the end-user */
  npsSurveys: Array<Maybe<EmbedNpsSurvey>>;
  organization: EmbedOrganization;
  stepAutoCompleteInteractions: Array<Maybe<EmbedStepAutoCompleteInteraction>>;
  uiSettings?: Maybe<EmbedOrganizationUiSettings>;
};


export type RootTypeGuideArgs = {
  guideEntityId: Scalars['EntityId'];
};

export type SaveGuideForLaterInput = {
  guideEntityId: Scalars['EntityId'];
};

export type SaveGuideForLaterPayload = {
  __typename?: 'SaveGuideForLaterPayload';
  errors?: Maybe<Array<Scalars['String']>>;
  guide?: Maybe<EmbedGuide>;
};

export type SegmentApiKey = {
  __typename?: 'SegmentApiKey';
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** The time of first successful integration */
  integratedAt?: Maybe<Scalars['DateTime']>;
  /** The API key for the organization to connect to Bento's segment integration */
  key: Scalars['String'];
  /** The organization that the Segment API key belongs to */
  organization: Organization;
  type?: Maybe<BentoApiKeyTypeEnum>;
};

export type SetStepAutoCompletionInput = {
  interactionEntityId: Scalars['EntityId'];
};

export type SetStepAutoCompletionPayload = {
  __typename?: 'SetStepAutoCompletionPayload';
  errors?: Maybe<Array<Scalars['String']>>;
  step?: Maybe<EmbedStep>;
};

export type SetStepCompletionInput = {
  ctaEntityId?: InputMaybe<Scalars['EntityId']>;
  /** The list of each input answer provided for the step, if any */
  inputAnswers?: InputMaybe<Array<InputFieldAnswerInput>>;
  isComplete: Scalars['Boolean'];
  stepEntityId: Scalars['EntityId'];
};

export type SetStepCompletionPayload = {
  __typename?: 'SetStepCompletionPayload';
  errors?: Maybe<Array<Scalars['String']>>;
  step?: Maybe<EmbedStep>;
};

export type SetStepSkippedInput = {
  isSkipped: Scalars['Boolean'];
  stepEntityId: Scalars['EntityId'];
};

export type SetStepSkippedPayload = {
  __typename?: 'SetStepSkippedPayload';
  errors?: Maybe<Array<Scalars['String']>>;
  step?: Maybe<EmbedStep>;
};

/** Whether or not the sidebar is available to users */
export enum SidebarAvailabilityType {
  Default = 'default',
  Hide = 'hide',
  NeverOpen = 'never_open'
}

/** The toggle visibility under specific conditions */
export enum SidebarVisibilityType {
  ActiveGuides = 'active_guides',
  ActiveOnboardingGuides = 'active_onboarding_guides',
  Hide = 'hide',
  Show = 'show'
}

export enum SplitTestStateEnumType {
  Deleted = 'deleted',
  Draft = 'draft',
  Live = 'live',
  None = 'none',
  Stopped = 'stopped'
}

/** A step that exists within a guide */
export type Step = {
  __typename?: 'Step';
  /** The auto complete interaction of a step */
  autoCompleteInteraction?: Maybe<StepAutoCompleteInteraction>;
  /**
   * The descriptive text of the step
   * @deprecated Maybe deprecate because it is not a case that exists anymore
   */
  body?: Maybe<Scalars['String']>;
  /** The Slate.JS RTE representation of the Step body */
  bodySlate?: Maybe<Scalars['JSON']>;
  branchingChoices?: Maybe<Array<BranchingChoice>>;
  branchingDismissDisabled?: Maybe<Scalars['Boolean']>;
  branchingFormFactor?: Maybe<BranchingFormFactorEnumType>;
  branchingKey?: Maybe<Scalars['String']>;
  branchingMultiple?: Maybe<Scalars['Boolean']>;
  branchingQuestion?: Maybe<Scalars['String']>;
  /** When was the step completed */
  completedAt?: Maybe<Scalars['DateTime']>;
  completedByAccountUser?: Maybe<AccountUser>;
  /** What kind of entity triggered the step completion */
  completedByType?: Maybe<StepCompletedBy>;
  completedByUser?: Maybe<User>;
  /** The number of account users who have viewed this step */
  countUsersViewed: Scalars['Int'];
  /** The step prototype that this step comes from */
  createdFromStepPrototype: StepPrototype;
  /** The CTAs of a step */
  ctas: Array<GuideBaseStepCta>;
  /** @deprecated not being used, might be removed */
  dismissLabel?: Maybe<Scalars['String']>;
  entityId: Scalars['EntityId'];
  /** Files that have been uploaded in steps created from this guide step base */
  fileUploads: Array<FileUpload>;
  guide?: Maybe<Guide>;
  /** Does the guide step base have any file uploads */
  hasFileUploads: Scalars['Boolean'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** Can the step be completed via auto completion */
  isAutoCompletable: Scalars['Boolean'];
  /**
   * Whether the step has been marked as completed
   * @deprecated Use 'completedAt'
   */
  isComplete: Scalars['Boolean'];
  /** Wether an auto complete step can be manually completed. */
  manualCompletionDisabled: Scalars['Boolean'];
  /** The media references associated to this step. */
  mediaReferences: Array<MediaReference>;
  /** The name of the step */
  name: Scalars['String'];
  /** The step that comes after */
  nextStep?: Maybe<Step>;
  orderIndex: Scalars['Int'];
  /** Whether or not step is required, optional, fyi, etc... */
  stepType: StepTypeEnum;
  updatedAt: Scalars['DateTime'];
  /** A list of account users who skipped this step */
  usersSkipped: Array<AccountUser>;
  /** A list of account users who viewed this step */
  usersViewed: Array<AccountUser>;
};

export type StepAutoCompleteInteraction = {
  __typename?: 'StepAutoCompleteInteraction';
  elementSelector: Scalars['String'];
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  step: GuideStepBase;
  type: StepAutoCompleteInteractionTypeEnumType;
  url: Scalars['String'];
  wildcardUrl: Scalars['String'];
};

/** The type of the step auto complete interaction */
export enum StepAutoCompleteInteractionTypeEnumType {
  Click = 'click'
}

export enum StepBodyOrientation {
  Horizontal = 'horizontal',
  Vertical = 'vertical'
}

export type StepBranchingPerformanceType = {
  __typename?: 'StepBranchingPerformanceType';
  /** Any new branching path that would result in adding the targeted module */
  activeBranchingPath?: Maybe<BranchingPath>;
  /**
   * Original branching path that triggered the branching
   * @deprecated Not implemented
   */
  branchingPath?: Maybe<BranchingPath>;
  choiceText?: Maybe<Scalars['String']>;
  createdModule?: Maybe<Module>;
  triggeredCount?: Maybe<Scalars['Int']>;
};

/** What kind of entity triggered the step completion */
export enum StepCompletedBy {
  AccountUser = 'accountUser',
  Auto = 'auto',
  User = 'user'
}

/** Number of steps associated with this sp, and how many are completed */
export type StepCompletionStatsType = {
  __typename?: 'StepCompletionStatsType';
  stepsCompleted?: Maybe<Scalars['Int']>;
  totalSteps?: Maybe<Scalars['Int']>;
  viewedSteps?: Maybe<Scalars['Int']>;
};

/** The step CTA settings */
export type StepCtaSettingsType = {
  __typename?: 'StepCtaSettingsType';
  bgColorField: Scalars['String'];
  eventName?: Maybe<Scalars['String']>;
  implicit?: Maybe<Scalars['Boolean']>;
  markComplete?: Maybe<Scalars['Boolean']>;
  opensInNewTab?: Maybe<Scalars['Boolean']>;
  textColorField: Scalars['String'];
};

/** The style of the step CTA */
export enum StepCtaStyleEnumType {
  Link = 'link',
  Outline = 'outline',
  Solid = 'solid'
}

/** The type of the step CTA */
export enum StepCtaTypeEnumType {
  Back = 'back',
  Complete = 'complete',
  Event = 'event',
  Launch = 'launch',
  Next = 'next',
  Save = 'save',
  Skip = 'skip',
  Url = 'url',
  UrlComplete = 'url_complete'
}

/** A mapping of an event to an auto-completion of a step prototype */
export type StepEventMapping = {
  __typename?: 'StepEventMapping';
  completeForWholeAccount: Scalars['Boolean'];
  entityId: Scalars['EntityId'];
  eventName: Scalars['String'];
  /** The ID of an object */
  id: Scalars['ID'];
  rules: Array<StepEventMappingRule>;
  stepPrototype: StepPrototype;
};

/** A prototype of a step that can be added to an account guide */
export type StepEventMappingRule = {
  __typename?: 'StepEventMappingRule';
  booleanValue?: Maybe<Scalars['Boolean']>;
  dateValue?: Maybe<Scalars['DateTime']>;
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  numberValue?: Maybe<Scalars['Int']>;
  propertyName: Scalars['String'];
  ruleType: StepEventMappingRuleRuleType;
  stepEventMappingRule: StepEventMapping;
  textValue?: Maybe<Scalars['String']>;
  valueType: StepEventMappingRuleValueType;
};

export enum StepEventMappingRuleRuleType {
  Eq = 'eq',
  Gt = 'gt',
  Gte = 'gte',
  Lt = 'lt',
  Lte = 'lte'
}

export enum StepEventMappingRuleValueType {
  Boolean = 'boolean',
  Date = 'date',
  Number = 'number',
  Text = 'text'
}

/** A prototype of a step that can be added to an account guide */
export type StepPrototype = {
  __typename?: 'StepPrototype';
  /**
   * The auto complete interaction of a step
   * @deprecated should be migrated over to `autoCompleteInteractions`
   */
  autoCompleteInteraction?: Maybe<StepPrototypeAutoCompleteInteraction>;
  /** Auto-complete interactions of a Step */
  autoCompleteInteractions?: Maybe<Array<Maybe<AutoCompleteInteraction>>>;
  /** The descriptive text of the step prototype */
  body?: Maybe<Scalars['String']>;
  /** The Slate.JS RTE representation of the Step prototype body */
  bodySlate?: Maybe<Scalars['JSON']>;
  branchingChoices?: Maybe<Array<BranchingChoice>>;
  branchingDismissDisabled?: Maybe<Scalars['Boolean']>;
  branchingEntityType?: Maybe<BranchingEntityTypeEnum>;
  branchingFormFactor?: Maybe<BranchingFormFactorEnumType>;
  branchingKey?: Maybe<Scalars['String']>;
  branchingMultiple?: Maybe<Scalars['Boolean']>;
  branchingPaths?: Maybe<Array<BranchingPath>>;
  branchingPerformance?: Maybe<Array<StepBranchingPerformanceType>>;
  branchingQuestion?: Maybe<Scalars['String']>;
  /** The CTAs of a step */
  ctas: Array<StepPrototypeCta>;
  dismissLabel?: Maybe<Scalars['String']>;
  entityId: Scalars['EntityId'];
  /**
   * Events or attributes that can auto-complete the step
   * @deprecated should be migrated over to `autoCompleteInteractions`
   */
  eventMappings: Array<StepEventMapping>;
  /** The ID of an object */
  id: Scalars['ID'];
  inputType?: Maybe<Scalars['String']>;
  /** The input prototypes of a step */
  inputs: Array<InputStepPrototype>;
  /** Can the step be completed via auto completion */
  isAutoCompletable: Scalars['Boolean'];
  /** Wether an auto complete step can be manually completed. */
  manualCompletionDisabled: Scalars['Boolean'];
  /** The media references associated to this step. */
  mediaReferences: Array<MediaReference>;
  /** The module in which this stepPrototype exists */
  module?: Maybe<Module>;
  /** The name of the step prototype */
  name: Scalars['String'];
  snappyAt?: Maybe<Scalars['DateTime']>;
  /** Counts of steps and steps completed */
  stepCompletionStats: StepCompletionStatsType;
  /** Whether or not step is required, optional, fyi, etc... */
  stepType: StepTypeEnum;
  /** Page elements selected to which to attach a context tag when this step is available */
  taggedElements: Array<StepPrototypeTaggedElement>;
  /** Templates this step prototype is part of */
  templates: Array<Maybe<Template>>;
};


/** A prototype of a step that can be added to an account guide */
export type StepPrototypeBranchingPerformanceArgs = {
  templateEntityId?: InputMaybe<Scalars['EntityId']>;
};


/** A prototype of a step that can be added to an account guide */
export type StepPrototypeStepCompletionStatsArgs = {
  templateEntityId?: InputMaybe<Scalars['EntityId']>;
};


/** A prototype of a step that can be added to an account guide */
export type StepPrototypeTaggedElementsArgs = {
  templateEntityId?: InputMaybe<Scalars['EntityId']>;
};

export type StepPrototypeAutoCompleteInteraction = {
  __typename?: 'StepPrototypeAutoCompleteInteraction';
  elementHtml?: Maybe<Scalars['String']>;
  elementSelector: Scalars['String'];
  elementText?: Maybe<Scalars['String']>;
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  stepPrototype: StepPrototype;
  type: StepAutoCompleteInteractionTypeEnumType;
  url: Scalars['String'];
  wildcardUrl: Scalars['String'];
};

export type StepPrototypeCta = {
  __typename?: 'StepPrototypeCta';
  /**
   * The entity id of the guide this cta should launch, if any
   * @deprecated Use destinationGuideObj
   */
  destinationGuide?: Maybe<Scalars['String']>;
  /** The guide this cta should launch, if any */
  destinationGuideObj?: Maybe<Template>;
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** Index that indicates the order for ctas. */
  orderIndex: Scalars['Int'];
  /** The settings of the step CTA */
  settings?: Maybe<StepCtaSettingsType>;
  stepPrototype: StepPrototype;
  style: StepCtaStyleEnumType;
  text: Scalars['String'];
  type: StepCtaTypeEnumType;
  url?: Maybe<Scalars['String']>;
};

export type StepPrototypeTaggedElement = {
  __typename?: 'StepPrototypeTaggedElement';
  alignment: ContextualTagAlignmentEnumType;
  elementHtml?: Maybe<Scalars['String']>;
  elementSelector: Scalars['String'];
  elementText?: Maybe<Scalars['String']>;
  entityId: Scalars['EntityId'];
  /** The ID of an object */
  id: Scalars['ID'];
  relativeToText: Scalars['Boolean'];
  stepPrototype?: Maybe<StepPrototype>;
  style?: Maybe<VisualTagStyleSettings>;
  template: Template;
  tooltipAlignment: ContextualTagTooltipAlignmentEnumType;
  type: ContextualTagTypeEnumType;
  url: Scalars['String'];
  wildcardUrl: Scalars['String'];
  xOffset: Scalars['Int'];
  yOffset: Scalars['Int'];
};

/** The Step separation style */
export type StepSeparationStyleType = {
  __typename?: 'StepSeparationStyleType';
  boxActiveStepShadow: ActiveStepShadowType;
  boxBorderRadius: Scalars['Int'];
  boxCompleteBackgroundColor?: Maybe<Scalars['String']>;
  type: StepSeparationType;
};

/** The Step separation type */
export enum StepSeparationType {
  Border = 'border',
  Box = 'box'
}

/** Indicates the current state of this step */
export enum StepState {
  Complete = 'complete',
  Incomplete = 'incomplete',
  Skipped = 'skipped'
}

/** What kind of step this is. e.g. required, optional */
export enum StepTypeEnum {
  Branching = 'branching',
  BranchingOptional = 'branching_optional',
  Fyi = 'fyi',
  Input = 'input',
  Optional = 'optional',
  Required = 'required'
}

export type Subscription = {
  __typename?: 'Subscription';
  /** The guides available to the account user changed */
  availableGuidesChanged?: Maybe<EmbedAvailableGuides>;
  /** A guide or any of its contents changed */
  guideChanged?: Maybe<EmbedGuide>;
  /** The organization's inline embeds changed */
  inlineEmbedsChanged?: Maybe<Array<Maybe<EmbedOrganizationInlineEmbed>>>;
  /** The organization's inline embeds changed */
  inlineEmbedsChangedNew?: Maybe<Array<Maybe<EmbedOrganizationInlineEmbed>>>;
  /** The step auto complete interactions available to the account user changed */
  stepAutoCompleteInteractionsChanged?: Maybe<EmbedStepAutoCompleteInteractions>;
};


export type SubscriptionAvailableGuidesChangedArgs = {
  accountUserExternalId?: InputMaybe<Scalars['String']>;
};


export type SubscriptionGuideChangedArgs = {
  guideEntityId: Scalars['EntityId'];
};


export type SubscriptionStepAutoCompleteInteractionsChangedArgs = {
  accountUserExternalId?: InputMaybe<Scalars['String']>;
};

/** Determine the visibility behavior of visual tags */
export enum TagVisibilityType {
  ActiveStep = 'active_step',
  Always = 'always'
}

export enum TargetAttributeRuleRuleTypeEnumType {
  All = 'all',
  Any = 'any',
  C = 'c',
  Empty = 'empty',
  Eq = 'eq',
  Gt = 'gt',
  Gte = 'gte',
  Lt = 'lt',
  Lte = 'lte',
  Nc = 'nc',
  Ne = 'ne',
  None = 'none',
  NotEmpty = 'notEmpty',
  Only = 'only',
  Re = 're',
  Rlt = 'rlt',
  Rmt = 'rmt'
}

/** A single group of targeting rules */
export type TargetGroupType = {
  __typename?: 'TargetGroupType';
  rules: Array<TargetRuleType>;
};

/** Determines the audience targeting criteria */
export type TargetRuleType = {
  __typename?: 'TargetRuleType';
  attribute: Scalars['String'];
  ruleType: TargetRuleTypeEnumType;
  value: Scalars['TargetValueScalarType'];
  valueType: AttributeValueTypeEnumType;
};

export enum TargetRuleTypeEnumType {
  All = 'all',
  Any = 'any',
  C = 'c',
  Empty = 'empty',
  Eq = 'eq',
  Gt = 'gt',
  Gte = 'gte',
  Lt = 'lt',
  Lte = 'lte',
  Nc = 'nc',
  Ne = 'ne',
  None = 'none',
  NotEmpty = 'notEmpty',
  Only = 'only',
  Re = 're',
  Rlt = 'rlt',
  Rmt = 'rmt'
}

/** Determines a given target criteria */
export type TargetType = {
  __typename?: 'TargetType';
  groups?: Maybe<Array<TargetGroupType>>;
  type: TargetTypeEnumType;
};

export enum TargetTypeEnumType {
  All = 'all',
  AttributeRules = 'attribute_rules',
  Role = 'role'
}

/** Determines targeting criteria */
export type TargetsType = {
  __typename?: 'TargetsType';
  account: TargetType;
  accountUser: TargetType;
  audiences?: Maybe<TargetType>;
};

export type Template = {
  __typename?: 'Template';
  /** The accounts that are using this template */
  accounts: Array<Account>;
  /**
   * The embed type (e.g. inline or sidebar) guides created from this template should be restricted to, if any.
   * @deprecated use formFactor
   */
  allowedEmbedType?: Maybe<GuideAllowedEmbedTypeEnumType>;
  announcementActivity: Array<Maybe<AnnouncementTimeSeriesPoint>>;
  /** Indicate this template will not show for users and is effectively gone */
  archivedAt?: Maybe<Scalars['DateTime']>;
  /** The number of account users that match auto launch rules */
  autoLaunchAudienceCount: Scalars['Int'];
  /** Automatically create and launch for this template when a new account is created? */
  autoLaunchForAccountsCreatedAfter?: Maybe<Scalars['DateTime']>;
  /** Represents number of accounts/users that have selected a branching path */
  branchedGuidesCount: Scalars['Int'];
  /** Step groups that can be branched to in this template */
  branchingModules: Array<Module>;
  /** List of step groups dynamically added by branching, and how many users selected them */
  branchingPerformance: Array<BranchingPerformance>;
  /** The description of the template */
  description?: Maybe<Scalars['String']>;
  /** The design type of the guide */
  designType: GuideDesignTypeEnumType;
  /** The timestamp at which auto-launch will be disabled */
  disableAutoLaunchAt?: Maybe<Scalars['DateTime']>;
  /**
   * Means the public name, previously meant the private name
   * @deprecated Use `name` instead
   */
  displayTitle?: Maybe<Scalars['String']>;
  /** Dynamic modules that target and can be appended to this template */
  dynamicModules: Array<Module>;
  /** The timestamp at which the template was last edited, or otherwise falls back to the timestamp at which the template was created if it has not yet been edited. */
  editedAt?: Maybe<Scalars['DateTime']>;
  /** The user that last edited the template */
  editedBy?: Maybe<User>;
  /** The timestamp at which auto-launch will be enabled */
  enableAutoLaunchAt?: Maybe<Scalars['DateTime']>;
  entityId: Scalars['EntityId'];
  /** After how many days the guide should expire */
  expireAfter?: Maybe<Scalars['Int']>;
  /** Criteria based on which to expire guides */
  expireBasedOn: GuideExpirationCriteria;
  /** The form factor this guide is meant to display as. */
  formFactor?: Maybe<GuideFormFactorEnumType>;
  /** Style properties for this guides form factor */
  formFactorStyle?: Maybe<FormFactorStyle>;
  /** Guide bases launched from this template */
  guideBases: Array<GuideBase>;
  /** Indicates whether the template has one or more guide bases that have been auto-launched */
  hasAutoLaunchedGuideBases: Scalars['Boolean'];
  /** Indicates whether the template has one or more guide bases */
  hasGuideBases: Scalars['Boolean'];
  /**
   * Whether a CYOA template has incomplete paths or not.
   * @deprecated CYOA paths are branching v1 and deprecated
   */
  hasIncompleteCYOAPaths: Scalars['Boolean'];
  /** The ID of an object */
  id: Scalars['ID'];
  /** The inline embed where this guide should be shown */
  inlineEmbed?: Maybe<OrganizationInlineEmbed>;
  /** If onboarding, the inline embed where it will show up */
  inlineOnboarding?: Maybe<OrganizationInlineEmbed>;
  /** @deprecated Use template stats to share caching mechanics */
  inputStepAnswersCount: Scalars['Int'];
  inputsCount: Scalars['Int'];
  /** Indicates if auto-launch is enabled for the template. */
  isAutoLaunchEnabled?: Maybe<Scalars['Boolean']>;
  /** Whether this guide is CYOA (single step guide that branches to another guide) */
  isCyoa: Scalars['Boolean'];
  /** Indicates whether the template is empty based on step body content */
  isEmpty: Scalars['Boolean'];
  /** Whether this guide is a side quest or a main quest. */
  isSideQuest?: Maybe<Scalars['Boolean']>;
  /** Whether or not active split tests are targeting this template */
  isTargetedForSplitTesting: SplitTestStateEnumType;
  /** If it is an unlaunchable template */
  isTemplate: Scalars['Boolean'];
  /** When was the template last used */
  lastUsedAt?: Maybe<Scalars['DateTime']>;
  launchedAt?: Maybe<Scalars['DateTime']>;
  /** Templates that launch this one, e.g. with branching or CTA destination */
  launchedBy: Array<Maybe<Template>>;
  /** What (wildcard) URLs might the user be exposed to the guide */
  locationShown?: Maybe<Scalars['String']>;
  /** The accounts to which this template has been manually launched */
  manuallyLaunchedAccounts: Array<Maybe<Account>>;
  /** The modules that comprise this template */
  modules: Array<Module>;
  /** Means the public name */
  name?: Maybe<Scalars['String']>;
  notificationSettings?: Maybe<TemplateNotificationSettings>;
  /** The number of accounts with unmodified guides created from this template */
  numberOfAccountsWithUnmodifiedGuides: Scalars['Int'];
  organization?: Maybe<Organization>;
  /** The type of page targeting mechanism */
  pageTargetingType: GuidePageTargetingEnumType;
  /** The URL for side quests page targeting, if enabled */
  pageTargetingUrl?: Maybe<Scalars['String']>;
  /** Number of customers using this template */
  participantCount?: Maybe<Scalars['Int']>;
  /** Ranking that indicates the order for auto-launchable templates. Higher rankings go first. */
  priorityRanking: Scalars['Int'];
  /** Means the private name */
  privateName?: Maybe<Scalars['String']>;
  /** The number of guides this template will propagate to */
  propagationCount: Scalars['Int'];
  /** Number of pending propagation jobs as a result of saving */
  propagationQueue: Scalars['Int'];
  /** Templates that this split test template leads to */
  splitSources: Array<Maybe<Template>>;
  /** Templates that this split test template leads to */
  splitTargets: Array<Maybe<Template>>;
  /** The state of the split test, if this template is of type split test. */
  splitTestState: SplitTestStateEnumType;
  /** The state of the template based on guide-bases created from it. */
  state: TemplateState;
  /** Template usage/completion stats */
  stats?: Maybe<TemplateStats>;
  stepPrototypes: Array<Maybe<StepPrototype>>;
  stepsCount: Scalars['Int'];
  stoppedAt?: Maybe<Scalars['DateTime']>;
  /** The visual tags attached only to the template and not to any steps in the template */
  taggedElements: Array<StepPrototypeTaggedElement>;
  /** When/if targeting has been set by the user manually, or by manual launching */
  targetingSet?: Maybe<Scalars['DateTime']>;
  /** The account and account user targeting rules for this template */
  targets?: Maybe<TargetsType>;
  /** The theme for this template */
  theme: ThemeType;
  /** Whether this template will create an account-specific guide or a user-specific guide */
  type: GuideTypeEnumType;
  updatedAt?: Maybe<Scalars['DateTime']>;
  /** The usage of the template in guide base and guide count */
  usage?: Maybe<TemplateUsage>;
  /** Whether a warning should be shown for an everboarding template with unpublished tags. */
  warnUnpublishedTag: Scalars['Boolean'];
};


export type TemplateBranchingPerformanceArgs = {
  detachedOnly?: InputMaybe<Scalars['Boolean']>;
};


export type TemplateStatsArgs = {
  useLocked?: InputMaybe<Scalars['Boolean']>;
};


export type TemplateTaggedElementsArgs = {
  checkFirstStepSupport?: InputMaybe<Scalars['Boolean']>;
};

/** Template last edited data */
export type TemplateLastEdited = {
  __typename?: 'TemplateLastEdited';
  timestamp?: Maybe<Scalars['DateTime']>;
  user?: Maybe<User>;
};

export type TemplateNotificationSettings = {
  __typename?: 'TemplateNotificationSettings';
  /** Disable notifying on action steps */
  action?: Maybe<Scalars['Boolean']>;
  /** Disable notifying on branching steps */
  branching?: Maybe<Scalars['Boolean']>;
  /** Disable notifications entirely */
  disable?: Maybe<Scalars['Boolean']>;
  /** Disable notifying on info steps */
  info?: Maybe<Scalars['Boolean']>;
  /** Disable notifying on input steps */
  input?: Maybe<Scalars['Boolean']>;
};

/** The current state of the template */
export enum TemplateState {
  Draft = 'draft',
  Live = 'live',
  Removed = 'removed',
  Stopped = 'stopped'
}

/** Template usage/completion stats */
export type TemplateStats = {
  __typename?: 'TemplateStats';
  /**
   * The number of guide bases created from this template
   * @deprecated Use guidesViewed instead for number of accounts that have seen the guide
   */
  accountsSeen?: Maybe<Scalars['Int']>;
  /** Avarege number of steps completed in each guide */
  averageStepsCompleted?: Maybe<Scalars['Float']>;
  /** Average steps completed but only counting those who have completed any steps */
  averageStepsCompletedForEngaged?: Maybe<Scalars['Float']>;
  /** Count of users that have completed a step in this guide */
  completedAStep?: Maybe<Scalars['Int']>;
  /**
   * The number of times any CTAs in this guide were clicked.
   * @deprecated Use usersClickedCta instead
   */
  ctaClickCount?: Maybe<Scalars['Int']>;
  /** The number of guides with a registered view */
  guidesViewed?: Maybe<Scalars['Int']>;
  /** The number of guides with at least one step complete */
  guidesWithCompletedStep?: Maybe<Scalars['Int']>;
  /** Count of input answers submitted, not deduped by users */
  inputStepAnswersCount?: Maybe<Scalars['Int']>;
  /** Out of all guides from this template, what percent are fully completed */
  percentCompleted?: Maybe<Scalars['Float']>;
  /** Same as percentCompleted but instead of total guides, it is out of total guides with a view */
  percentGuidesCompleted?: Maybe<Scalars['Float']>;
  /** Raw number of steps that are complete */
  totalStepsCompleted?: Maybe<Scalars['Int']>;
  /** Count of unique users that have submitted an answer to input fields */
  usersAnswered?: Maybe<Scalars['Int']>;
  /** Count of unique users that have clicked a CTA */
  usersClickedCta?: Maybe<Scalars['Int']>;
  /** Count of users that dismissed an announcement (e.g. skipped step) */
  usersDismissed?: Maybe<Scalars['Int']>;
  /** Count of users that saved an announcement for later */
  usersSavedForLater?: Maybe<Scalars['Int']>;
  /** Count of users that have seen a step in this guide */
  usersSeenGuide?: Maybe<Scalars['Int']>;
};

export type TemplateUsage = {
  __typename?: 'TemplateUsage';
  /** Number of guide bases auto launched */
  autoLaunchedAccounts: Scalars['Int'];
  /** Number of guides auto launched */
  autoLaunchedUsers: Scalars['Int'];
  /** Number of guide bases manual launched */
  manualLaunchedAccounts: Scalars['Int'];
  /** Number of guides manual launched */
  manualLaunchedUsers: Scalars['Int'];
};

export type TextOrEmailSettings = {
  __typename?: 'TextOrEmailSettings';
  helperText?: Maybe<Scalars['String']>;
  maxValue?: Maybe<Scalars['Int']>;
  placeholder?: Maybe<Scalars['String']>;
  required: Scalars['Boolean'];
};

/** Guide themes */
export enum ThemeType {
  Card = 'card',
  Carousel = 'carousel',
  Mailchimp = 'mailchimp',
  Minimal = 'minimal',
  Standard = 'standard',
  Timeline = 'timeline',
  VideoGallery = 'videoGallery'
}

export enum TooltipShowOn {
  PageLoad = 'page_load',
  TagHover = 'tag_hover'
}

export enum TooltipSize {
  Large = 'large',
  Medium = 'medium',
  Small = 'small'
}

export type TooltipStyle = {
  __typename?: 'TooltipStyle';
  backgroundColor?: Maybe<Scalars['String']>;
  backgroundOverlayColor?: Maybe<Scalars['String']>;
  backgroundOverlayOpacity?: Maybe<Scalars['Int']>;
  canDismiss?: Maybe<Scalars['Boolean']>;
  ctasOrientation?: Maybe<CtasOrientation>;
  hasArrow: Scalars['Boolean'];
  hasBackgroundOverlay: Scalars['Boolean'];
  height?: Maybe<Scalars['Int']>;
  horizontalMediaAlignment?: Maybe<HorizontalMediaAlignment>;
  imageWidth?: Maybe<Scalars['String']>;
  mediaFontSize?: Maybe<Scalars['Int']>;
  mediaOrientation?: Maybe<MediaOrientation>;
  mediaTextColor?: Maybe<Scalars['String']>;
  stepBodyOrientation?: Maybe<StepBodyOrientation>;
  textColor?: Maybe<Scalars['String']>;
  tooltipShowOn: TooltipShowOn;
  tooltipSize: TooltipSize;
  verticalMediaAlignment?: Maybe<VerticalMediaAlignment>;
  verticalMediaOrientation?: Maybe<VerticalMediaOrientation>;
};

/** The org tooltips styles */
export type TooltipsStyleStyleType = {
  __typename?: 'TooltipsStyleStyleType';
  borderRadius?: Maybe<Scalars['Int']>;
  paddingX?: Maybe<Scalars['Int']>;
  paddingY?: Maybe<Scalars['Int']>;
  shadow?: Maybe<AnnouncementShadowType>;
};

export type TrackCtaClickedInput = {
  ctaEntityId?: InputMaybe<Scalars['EntityId']>;
  stepEntityId: Scalars['EntityId'];
};

export type TrackCtaClickedPayload = {
  __typename?: 'TrackCtaClickedPayload';
  errors?: Maybe<Array<Scalars['String']>>;
};

export type TrackGuideViewInput = {
  formFactor: Scalars['String'];
  guideEntityId?: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
};

export type TrackGuideViewPayload = {
  __typename?: 'TrackGuideViewPayload';
  errors?: Maybe<Array<Scalars['String']>>;
  formFactor: Scalars['String'];
  guideEntityId?: Maybe<Scalars['String']>;
  type: Scalars['String'];
};

export type TrackNpsSurveyViewedInput = {
  /** Entity ID of the NPS survey */
  entityId: Scalars['EntityId'];
};

export type TrackNpsSurveyViewedPayload = {
  __typename?: 'TrackNpsSurveyViewedPayload';
  errors?: Maybe<Array<Scalars['String']>>;
  npsSurvey?: Maybe<EmbedNpsSurvey>;
};

export type TrackStepViewInput = {
  formFactor: Scalars['String'];
  stepEntityId?: InputMaybe<Scalars['String']>;
  type: Scalars['String'];
};

export type TrackStepViewPayload = {
  __typename?: 'TrackStepViewPayload';
  errors?: Maybe<Array<Scalars['String']>>;
  formFactor: Scalars['String'];
  stepEntityId?: Maybe<Scalars['String']>;
  type: Scalars['String'];
};

export type TwoWayState = {
  __typename?: 'TwoWayState';
  downState?: Maybe<IntegrationStateEnum>;
  upState?: Maybe<IntegrationStateEnum>;
};

export type User = {
  __typename?: 'User';
  allOrgs: Array<Maybe<Organization>>;
  avatarUrl?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  email: Scalars['String'];
  entityId: Scalars['EntityId'];
  extra?: Maybe<Scalars['JSON']>;
  fullName?: Maybe<Scalars['String']>;
  hasAssignedAccounts: Scalars['Boolean'];
  hasBentoOnboardingGuide: Scalars['Boolean'];
  /** The ID of an object */
  id: Scalars['ID'];
  isBentoOnboardingGuideComplete: Scalars['Boolean'];
  isSuperadmin: Scalars['Boolean'];
  orgSettings?: Maybe<OrganizationOrgSettings>;
  organization: Organization;
  phoneNumber?: Maybe<Scalars['String']>;
};

export enum VerticalMediaAlignment {
  Bottom = 'bottom',
  Center = 'center',
  Top = 'top'
}

export enum VerticalMediaOrientation {
  Bottom = 'bottom',
  Top = 'top'
}

export type VideoGalleryStyle = {
  __typename?: 'VideoGalleryStyle';
  advancedPadding?: Maybe<Scalars['String']>;
  backgroundColor?: Maybe<Scalars['String']>;
  borderColor?: Maybe<Scalars['String']>;
  borderRadius?: Maybe<Scalars['Int']>;
  canDismiss?: Maybe<Scalars['Boolean']>;
  mediaFontSize?: Maybe<Scalars['Int']>;
  mediaTextColor?: Maybe<Scalars['String']>;
  padding?: Maybe<Scalars['Int']>;
  selectedBackgroundColor?: Maybe<Scalars['String']>;
  statusLabelColor?: Maybe<Scalars['String']>;
  textColor?: Maybe<Scalars['String']>;
};

export type VideoMediaMeta = {
  __typename?: 'VideoMediaMeta';
  videoId?: Maybe<Scalars['String']>;
  videoType?: Maybe<Scalars['String']>;
};

export type VideoMediaReferenceSettings = {
  __typename?: 'VideoMediaReferenceSettings';
  alignment?: Maybe<Scalars['String']>;
  playsInline?: Maybe<Scalars['Boolean']>;
};

export type VisualTagHighlightSettings = {
  __typename?: 'VisualTagHighlightSettings';
  color?: Maybe<Scalars['String']>;
  opacity?: Maybe<Scalars['Float']>;
  padding?: Maybe<Scalars['Int']>;
  pulse?: Maybe<Scalars['Boolean']>;
  radius?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  thickness?: Maybe<Scalars['Int']>;
  type?: Maybe<VisualTagHighlightType>;
};

export enum VisualTagHighlightType {
  Halo = 'halo',
  None = 'none',
  Overlay = 'overlay',
  Solid = 'solid'
}

export enum VisualTagPulseLevelType {
  None = 'none',
  Standard = 'standard'
}

export type VisualTagStyleSettings = VisualTagHighlightSettings;

export type Webhook = {
  __typename?: 'Webhook';
  entityId: Scalars['EntityId'];
  /** The API key for the organization to connect to Bento's segment integration */
  eventType: EventHookTypeEnum;
  /** The ID of an object */
  id: Scalars['ID'];
  /** The organization that the webhook belongs to */
  organization: Organization;
  /** Used to verify Bento with the recipient */
  secretKey?: Maybe<Scalars['String']>;
  state: WebhookStateTypeEnum;
  webhookType: WebhookTypeTypeEnum;
  /** Where to send the data payload */
  webhookUrl: Scalars['String'];
};

export enum WebhookStateTypeEnum {
  Active = 'active',
  Inactive = 'inactive'
}

export enum WebhookTypeTypeEnum {
  Standard = 'standard'
}

export type ZendeskState = {
  __typename?: 'ZendeskState';
  /** @deprecated Use orgSettings.helpCenter instead */
  issueSubmission?: Maybe<Scalars['Boolean']>;
  /** @deprecated Use orgSettings.helpCenter instead */
  kbSearch?: Maybe<Scalars['Boolean']>;
  /** @deprecated Use orgSettings.helpCenter instead */
  liveChat?: Maybe<Scalars['Boolean']>;
  subdomain?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
};

export type SelectBranchingPathInput = {
  /** Set of branching paths to reference */
  branchingKey: Scalars['String'];
  /** keys for paths to take */
  choiceKeys?: InputMaybe<Array<Scalars['String']>>;
  /** user-facing labels for the chosen paths */
  choiceLabels?: InputMaybe<Array<Scalars['String']>>;
  shouldCompleteStep: Scalars['Boolean'];
  /** The associated branching step */
  stepEntityId?: InputMaybe<Scalars['EntityId']>;
};

export type SelectBranchingPathPayload = {
  __typename?: 'selectBranchingPathPayload';
  errors?: Maybe<Array<Scalars['String']>>;
};
