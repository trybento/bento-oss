import { uniq } from 'lodash';
import { Op } from 'sequelize';
import { AttributeType } from 'bento-common/types';
import { guidePrivateOrPublicNameOrFallback } from 'bento-common/utils/naming';

import { CustomAttribute } from 'src/data/models/CustomAttribute.model';
import { Organization } from 'src/data/models/Organization.model';
import { StepPrototype } from 'src/data/models/StepPrototype.model';
import { Template } from 'src/data/models/Template.model';
import { Account } from 'src/data/models/Account.model';
import { AccountUser } from 'src/data/models/AccountUser.model';
import { enableInternalGuideNames } from 'src/utils/features';

type Args = {
  attributeName: string;
  organization: Organization;
  limit?: number;
};

export enum ComputedAttributeType {
  branching = 'branching',
  guideReceived = 'guideReceived',
  accountId = 'accountId',
  accountUserId = 'accountUserId',
  accountName = 'accountName',
  accountUserFullName = 'accountUserFullName',
  accountCreatedAt = 'accountCreatedAt',
  accountUserCreatedAt = 'accountUserCreatedAt',
  email = 'email',
}

type ComputedAttributeResolver = (args: Args) => Promise<(Date | string)[]>;

/** Generated by Bento, we do not store into CustomAttributeValues */
export const getComputedAttributeInfo = (attribute: {
  name: string;
  [other: string]: any;
}): [ComputedAttributeType?, ComputedAttributeResolver?] => {
  /* "Custom" attributes we populate */
  if (attribute.name === 'fullName')
    return [
      ComputedAttributeType.accountUserFullName,
      async ({ organization, limit }) => {
        const accountUsers = await AccountUser.findAll({
          where: {
            organizationId: organization.id,
            fullName: {
              [Op.ne]: null,
            } as any,
          },
          attributes: ['fullName'],
          limit,
        });

        return accountUsers.map((au) => au.fullName || '');
      },
    ];
  if (attribute.name === 'name' && attribute.type === AttributeType.account)
    return [
      ComputedAttributeType.accountName,
      async ({ organization, limit }) => {
        const accounts = await Account.findAll({
          where: {
            organizationId: organization.id,
          },
          attributes: ['name'],
          limit,
        });

        return accounts.map((a) => a.name || '');
      },
    ];
  if (attribute.name === 'email')
    return [
      ComputedAttributeType.email,
      async ({ organization, limit }) => {
        const accountUsers = await AccountUser.findAll({
          where: {
            organizationId: organization.id,
            email: {
              [Op.ne]: null,
            } as any,
          },
          attributes: ['email'],
          limit,
        });

        return accountUsers.map((au) => au.email || '');
      },
    ];
  if (attribute.name === 'createdAt')
    return attribute.type === AttributeType.account
      ? [
          ComputedAttributeType.accountCreatedAt,
          async ({ organization, limit }) => {
            const accounts = await Account.findAll({
              where: {
                organizationId: organization.id,
                createdInOrganizationAt: {
                  [Op.ne]: null,
                } as any,
              },
              attributes: ['createdInOrganizationAt'],
              limit,
            });

            return accounts.map((a) =>
              a.createdInOrganizationAt!.toISOString()
            );
          },
        ]
      : [
          ComputedAttributeType.accountUserCreatedAt,
          async ({ organization, limit }) => {
            const accountUsers = await AccountUser.findAll({
              where: {
                organizationId: organization.id,
                createdInOrganizationAt: {
                  [Op.ne]: null,
                } as any,
              },
              attributes: ['createdInOrganizationAt'],
              limit,
            });

            return accountUsers.map((au) =>
              au.createdInOrganizationAt!.toISOString()
            );
          },
        ];

  const isCustomAttributeInstance = attribute instanceof CustomAttribute;

  if (isCustomAttributeInstance) return [];

  if (attribute.name === 'Guide received') {
    return [
      ComputedAttributeType.guideReceived,
      async ({ organization, limit }) => {
        const enabledInternalNames = await enableInternalGuideNames.enabled(
          organization.id
        );

        const templates = await Template.scope('contentTemplates').findAll({
          where: {
            organizationId: organization.id,
          },
          attributes: ['privateName', 'name'],
          limit,
        });

        return templates.map((t) =>
          guidePrivateOrPublicNameOrFallback(enabledInternalNames, t)
        );
      },
    ];
  }

  const isBranchingAttr =
    attribute.name && attribute.name.startsWith('Branching:');

  if (isBranchingAttr)
    return [
      ComputedAttributeType.branching,
      async ({ attributeName, organization, limit }) => {
        const branchingQuestion = attributeName.replace('Branching: ', '');

        const matchingSteps = await StepPrototype.findAll({
          where: {
            organizationId: organization.id,
            branchingQuestion,
          },
          attributes: ['branchingChoices'],
        });

        const allMatchedChoices = matchingSteps.reduce((a, sp) => {
          sp.branchingChoices?.forEach((c) => a.push(c.label));
          return a;
        }, [] as string[]);

        return uniq(allMatchedChoices).slice(0, limit);
      },
    ];

  if (attribute.name === 'id' && attribute.type === AttributeType.account)
    return [
      ComputedAttributeType.accountId,
      async ({ organization, limit }) => {
        const accounts = await Account.findAll({
          where: {
            organizationId: organization.id,
          },
          attributes: ['externalId'],
          limit,
        });

        return accounts.map((a) => a.externalId || '');
      },
    ];
  if (attribute.name === 'id' && attribute.type === AttributeType.accountUser)
    return [
      ComputedAttributeType.accountUserId,
      async ({ organization, limit }) => {
        const accountUsers = await AccountUser.findAll({
          where: {
            organizationId: organization.id,
          },
          attributes: ['externalId'],
          limit,
        });

        return accountUsers.map((au) => au.externalId || '');
      },
    ];

  return [];
};
