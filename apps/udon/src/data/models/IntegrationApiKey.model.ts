import {
  AllowNull,
  BelongsTo,
  Column,
  DataType,
  Default,
  ForeignKey,
  Model,
  Table,
  Scopes,
  Comment,
} from 'sequelize-typescript';
import {
  GroupCondition,
  IntegrationApiKeyTargeting,
  IntegrationType,
  TargetingType,
  WritableKeys,
} from 'bento-common/types';
import { IntegrationState } from 'bento-common/types/integrations';
import { EnumColumn } from 'bento-common/utils/sequelize';

import { EntityId, CreatedAt, UpdatedAt } from './columns';
import { Organization } from './Organization.model';
import Encryption from 'src/utils/cryptr';
import {
  CreationOptional,
  InferAttributes,
  InferCreationAttributes,
  NonAttribute,
  Op,
} from 'sequelize';

type WritableIntegrationKeys = Pick<
  IntegrationApiKey,
  WritableKeys<Omit<IntegrationApiKey, keyof Model>>
>;

/** List of keys we want to encrypt on store */
const encryptedKeys: Array<keyof WritableIntegrationKeys> = [
  'key',
  'refreshToken',
];

const handleKeys = (
  instance: IntegrationApiKey,
  operation: keyof typeof Encryption
) => {
  encryptedKeys.forEach((k) => {
    if (!instance[k]) return;

    instance[k] = Encryption[operation](instance[k]);
  });
};

const encryptKey = (instance: IntegrationApiKey) =>
  handleKeys(instance, 'encrypt');

@Scopes(() => ({
  hasRefreshToken: {
    where: {
      refreshToken: { [Op.ne]: null },
    },
  },
  [IntegrationState.Active]: {
    where: {
      state: IntegrationState.Active,
    },
  },
}))
/**
 * We're storing customer keys here, so best not do that in plaintext.
 *
 * Needs to be reloaded for model to have proper key and call before load again
 */
@Table({
  schema: 'core',
  tableName: 'integration_api_keys',
  hooks: {
    beforeCreate: encryptKey,
    beforeUpdate: encryptKey,
    afterFind: (results) => {
      if (results && Array.isArray(results)) {
        results.forEach((i: IntegrationApiKey) => handleKeys(i, 'decrypt'));
      } else if (results && results instanceof IntegrationApiKey) {
        handleKeys(results, 'decrypt');
      }
    },
  },
})

/**
 * Integration keys generated by another service, which we need to store to access the service
 */
export class IntegrationApiKey<T = Record<string, any>> extends Model<
  InferAttributes<IntegrationApiKey>,
  InferCreationAttributes<
    IntegrationApiKey,
    { omit: 'createdAt' | 'updatedAt' }
  >
> {
  readonly id!: CreationOptional<number>;

  @EntityId
  readonly entityId!: CreationOptional<string>;

  /** API key or accessToken */
  @AllowNull(false)
  @Column({ type: DataType.TEXT })
  key!: string;

  @AllowNull(true)
  @Column({ field: 'refresh_token', type: DataType.TEXT })
  refreshToken!: CreationOptional<string>;

  @AllowNull(false)
  @EnumColumn('type', IntegrationType)
  readonly type!: IntegrationType;

  @Default({})
  @Column({ field: 'options', type: DataType.JSONB })
  readonly options!: T; // TODO: type, depends on integration type

  @Comment('First time the integration was run, indicating successful setup')
  @AllowNull(true)
  @Column({ field: 'integrated_at', type: DataType.DATE })
  readonly integratedAt?: CreationOptional<Date | null>;

  @Comment(
    'Last time this integration automatically ran. Should not include manual triggers.'
  )
  @AllowNull(true)
  @Column({ field: 'last_run_at', type: DataType.DATE })
  readonly lastRunAt?: CreationOptional<Date | null>;

  @AllowNull(true)
  @Column({ field: 'last_error_at', type: DataType.DATE })
  readonly lastErrorAt?: CreationOptional<Date | null>;

  @Comment(
    'Relevant for integrations where there is only one direction of data. Use options for deeper integrations.'
  )
  @AllowNull(false)
  @Default(IntegrationState.Active)
  @EnumColumn('state', IntegrationState)
  readonly state!: IntegrationState;

  @ForeignKey(() => Organization)
  @AllowNull(false)
  @Column({ field: 'organization_id', type: DataType.INTEGER })
  readonly organizationId!: number;

  @CreatedAt
  readonly createdAt!: Date;

  @UpdatedAt
  readonly updatedAt!: Date;

  @Default({
    account: {
      type: TargetingType.all,
      rules: [],
      grouping: GroupCondition.all,
    },
    accountUser: {
      type: TargetingType.all,
      rules: [],
      grouping: GroupCondition.all,
    },
  })
  @Column({ field: 'targeting', type: DataType.JSONB })
  /** @deprecated Not currently supported. Rebuild with new targeting (see: templates) to bring back. */
  readonly targeting!: CreationOptional<IntegrationApiKeyTargeting>;

  // ASSOCIATIONS
  @BelongsTo(() => Organization)
  readonly organization!: NonAttribute<Organization>;
}

export { IntegrationType } from 'bento-common/types';
