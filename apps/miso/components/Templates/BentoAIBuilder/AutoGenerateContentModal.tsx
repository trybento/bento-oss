import React, { useCallback, useState, useEffect } from 'react';
import {
  Button,
  ButtonGroup,
  ModalCloseButton,
  ModalContent,
  ModalFooter,
  ModalHeader,
  ModalOverlay,
  Textarea,
  Box,
  VStack,
  Text,
  UnorderedList,
  ListItem,
} from '@chakra-ui/react';
import { Modal } from 'bento-common/components/Modal';
import ModalBody from 'system/ModalBody';
import Radio from 'system/Radio';
import RadioGroup from 'system/RadioGroup';
import useToggleState from 'hooks/useToggleState';
import useAccessToken from 'hooks/useAccessToken';
import fetchAutoGeneratedContent from 'utils/fetchAutoGeneratedContent';
import { useTemplate } from 'providers/TemplateProvider';
import { isJsonError } from 'bento-common/utils/strings';
import colors from 'helpers/colors';
import UrlInput from 'components/common/UrlInput';
import { noop } from 'bento-common/utils/functions';
import { GptErrors, GptMethod } from 'bento-common/types';
import { GPTGeneratedGuide } from 'bento-common/types/integrations';
import { EmojiList, EmojiListItem } from 'bento-common/components/EmojiList';
import GptLoader from './GptLoader';
import {
  GenerationMethod,
  getErrorMessage,
} from './autoGenerateContent.helpers';

interface AutoGenerateContentModalProps {
  isOpen: boolean;
  onCancel: () => void;
  onConfirm: (results: GPTGeneratedGuide) => void;
  onError: (message: string) => void;
}

/**
 * @todo Components for each generation method to reduce shared state mess
 */
const AutoGenerateContentModal: React.FC<AutoGenerateContentModalProps> = ({
  isOpen,
  onCancel,
  onConfirm,
  onError,
}): JSX.Element => {
  const loadingState = useToggleState(['generating']);
  const [transcript, setTranscript] = useState('');
  const [link, setLink] = useState('');
  const [articleText, setArticleText] = useState<string | null>(null);
  const [generationMethod, setGenerationMethod] = useState(null);
  const [lastError, setLastError] = useState<GptErrors | null>(null);
  /**
   * @todo reduce overlap with generationMethod
   * As of now it would break the top level radio group since it only maps to three buttons
   *   each radio button will need to support mapping 1-n gen methods
   */
  const [subGenerationMethod, setSubGenerationMethod] = useState(
    GptMethod.baseScraper
  );

  const { accessToken } = useAccessToken();
  const {
    template: { entityId: templateEntityId },
  } = useTemplate();

  const onGptError = useCallback(
    (err: string) => {
      const castErr = err as GptErrors;
      const message = getErrorMessage(castErr, subGenerationMethod);
      setLastError(castErr);

      /* Show text area if we can't scrape, or article too long */
      if (err === GptErrors.scrapeError || err === GptErrors.tokenError)
        setSubGenerationMethod(GptMethod.article);

      /* Suppress toasting if link errors, because we have the info UI */
      if (generationMethod === GenerationMethod.links) return;
      onError(message);
    },
    [onError, subGenerationMethod, generationMethod]
  );

  const handleOnConfirm = useCallback(async () => {
    try {
      loadingState.generating.on();

      /**
       * @todo: cleanup, multi-links no longer supported. Remove array typings.
       */
      const _link =
        articleText !== null
          ? undefined
          : link.split(',').reduce((a, l) => {
              l && a.push(l.trim());
              return a;
            }, [] as string[]);

      const res = await fetchAutoGeneratedContent({
        accessToken,
        templateEntityId,
        ...(generationMethod === GenerationMethod.links
          ? { method: subGenerationMethod }
          : {}),
        ...(generationMethod === GenerationMethod.transcript
          ? {
              transcript,
            }
          : {
              articleText,
              links: _link,
            }),
      });

      loadingState.generating.off();

      /* Reset to initial state */
      if (generationMethod === GenerationMethod.links)
        setSubGenerationMethod(GptMethod.baseScraper);

      if (res.error) throw new Error(res.error);

      /* Clear errors and set success */
      if (generationMethod === GenerationMethod.links) setArticleText(null);
      setLastError(null);
      onConfirm(res.choices[0]);
      onCancel();
    } catch (e: any) {
      if (e.message && isJsonError(e.message))
        onGptError(GptErrors.malformedJson);
      else onGptError(e.message);
    }
  }, [
    onCancel,
    onConfirm,
    accessToken,
    transcript,
    link,
    generationMethod,
    articleText,
    subGenerationMethod,
  ]);

  const handleTranscriptChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      setTranscript(e.target.value);
    },
    []
  );

  const handleArticleTextChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      setArticleText(e.target.value);
    },
    []
  );

  const handleLinkChange = useCallback(
    (value: string) => {
      setLink(value);
      if (articleText !== null) setArticleText(null);
    },
    [articleText]
  );

  useEffect(() => {
    /* Resets on close */
    setSubGenerationMethod(GptMethod.baseScraper);
    setLastError(null);
  }, [isOpen]);

  return (
    <Modal
      isOpen={isOpen}
      onClose={onCancel}
      size="xl"
      closeOnOverlayClick={!loadingState.generating.isOn}
    >
      <ModalOverlay />
      <ModalContent display="table" w="xl">
        <ModalHeader>Create guide with BentoAI</ModalHeader>
        <ModalCloseButton disabled={loadingState.generating.isOn} />
        <ModalBody w="xl">
          {loadingState.generating.isOn ? (
            <GptLoader generationMethod={generationMethod} />
          ) : (
            <VStack h="full" alignItems="flex-start" w="full">
              {!lastError && (
                <>
                  <Text>How would you like to create your guide?</Text>
                  <RadioGroup
                    defaultValue={generationMethod}
                    onChange={setGenerationMethod as (v: string) => void}
                    spacing="4"
                  >
                    <Radio
                      value={GenerationMethod.transcript}
                      label="Transcript"
                    />
                    <Radio
                      value={GenerationMethod.links}
                      label="Help center article"
                      textStyles={{ whiteSpace: 'nowrap' }}
                    />
                    <Radio
                      value={GenerationMethod.clickThrough}
                      isDisabled
                      label="Click through (coming soon)"
                      textStyles={{ whiteSpace: 'nowrap' }}
                    />
                  </RadioGroup>
                </>
              )}
              {generationMethod === GenerationMethod.transcript ? (
                <>
                  <Box py="4">
                    <Text mb="2">How it works:</Text>
                    <UnorderedList px="2" styleType="none" spacing="2">
                      <ListItem>
                        ðŸŽ¤ Record yourself walking through your onboarding flow{' '}
                      </ListItem>
                      <ListItem>
                        ðŸ“„ Grab the transcript (tools like Loom will generate
                        that for you!)
                      </ListItem>
                      <ListItem>
                        ðŸ¤– BentoAI will generate a guide based on the
                        transcript!
                      </ListItem>
                    </UnorderedList>
                  </Box>
                  <Text fontWeight="semibold">Transcript</Text>
                  <Textarea
                    value={transcript}
                    fontSize="sm"
                    flex="1"
                    resize="none"
                    minHeight="20vh"
                    onChange={handleTranscriptChange}
                    placeholder="First you go here..."
                  />
                  <Text mb="4" color={colors.text.secondary}>
                    We recommend transcripts from videos that are 2-5 min.
                  </Text>
                </>
              ) : generationMethod === GenerationMethod.links ? (
                <>
                  <Box>
                    {!lastError ? (
                      <EmojiList header="How it works:">
                        <EmojiListItem emoji="ðŸ“š">
                          Add the link of a relevant help center article
                        </EmojiListItem>
                        <EmojiListItem emoji="ðŸ¤–">
                          BentoAI will read through the article and generate a
                          guide
                        </EmojiListItem>
                      </EmojiList>
                    ) : (
                      <EmojiList pt="0" px="0">
                        <EmojiListItem emoji="ðŸš¨">
                          Uh oh, we are unable to scrape that page
                          {lastError === GptErrors.staticScrapeError
                            ? ''
                            : ' or the text is too long'}
                          .
                        </EmojiListItem>
                        {lastError === GptErrors.staticScrapeError && (
                          <EmojiListItem emoji="ðŸ”„">
                            You can paste in the help article text or we can try
                            a different scraping method (can take up to 30 sec).
                          </EmojiListItem>
                        )}
                        {lastError !== GptErrors.staticScrapeError && (
                          <EmojiListItem emoji="ðŸ”„">
                            You can paste in the help article text. Try to use
                            just the important parts of the article.
                          </EmojiListItem>
                        )}
                      </EmojiList>
                    )}
                  </Box>
                  <Text fontWeight="semibold">Help center article link</Text>
                  <Box w="full">
                    <UrlInput
                      initialUrl={link}
                      onContentChange={handleLinkChange}
                      onEnter={handleOnConfirm}
                      withCallout={false}
                      placeholder="Link to help article"
                      hideInitialContent
                    />
                  </Box>
                  {lastError === GptErrors.staticScrapeError && (
                    <VStack mt="4" h="full" alignItems="flex-start" w="full">
                      <Text fontWeight="semibold">
                        How would you like to try again?
                      </Text>
                      <RadioGroup
                        defaultValue={generationMethod}
                        onChange={setSubGenerationMethod as (v: string) => void}
                        spacing="4"
                      >
                        <Radio
                          value={GptMethod.externalScraper}
                          label="Different scraping method"
                          textStyles={{ whiteSpace: 'nowrap' }}
                        />
                        <Radio
                          value={GptMethod.article}
                          label="Paste in text"
                          textStyles={{ whiteSpace: 'nowrap' }}
                        />
                      </RadioGroup>
                    </VStack>
                  )}
                  {subGenerationMethod === GptMethod.article && (
                    <VStack mt="4" w="full" alignItems="flex-start">
                      <Text fontWeight="semibold">Help article text</Text>
                      <Textarea
                        value={articleText}
                        fontSize="sm"
                        flex="1"
                        resize="none"
                        minHeight="20vh"
                        onChange={handleArticleTextChange}
                        placeholder="First you go here..."
                      />
                    </VStack>
                  )}
                </>
              ) : null}
            </VStack>
          )}
        </ModalBody>
        <ModalFooter
          display="flex"
          justifyContent="space-between"
          alignContent="center"
        >
          <Box />
          {!loadingState.generating.isOn && (
            <ButtonGroup>
              <Button
                variant="secondary"
                isDisabled={loadingState.generating.isOn}
                onClick={onCancel}
              >
                Cancel
              </Button>
              <Button
                isDisabled={
                  loadingState.generating.isOn ||
                  (!transcript && !link && !articleText) ||
                  (link && articleText === '')
                }
                onClick={handleOnConfirm}
              >
                Generate
              </Button>
            </ButtonGroup>
          )}
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
};

export const AutoGeneratedContentLoadingModal: React.FC<{
  isOpen?: boolean;
}> = ({ isOpen = true }): JSX.Element => {
  return (
    <Modal isOpen={isOpen} onClose={noop} size="xl" closeOnOverlayClick={false}>
      <ModalOverlay />
      <ModalContent display="table" w="xl" h="400px">
        <ModalBody w="xl">
          <GptLoader generationMethod={GenerationMethod.clickThrough} />
        </ModalBody>
      </ModalContent>
    </Modal>
  );
};

export default AutoGenerateContentModal;
