import React, {
  createContext,
  MutableRefObject,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import debounce from 'lodash/debounce';
import pick from 'lodash/pick';
import noop from 'lodash/noop';
import { useRouter } from 'next/router';
import { useFormikContext } from 'formik';
import { v4 as uuidv4 } from 'uuid';

import {
  AutoGuideBuilderData,
  ChecklistStyle,
  GuidePageTargetingType,
  OnCreateBehavior,
  VisualBuilderSessionType,
  WysiwygEditorMode,
  WysiwygEditorState,
} from 'bento-common/types';
import {
  CardStyle,
  GuideExpirationCriteria,
  GuideTypeEnum,
  MediaOrientation,
  SplitTestState,
  StepBodyOrientation,
  Theme,
  VerticalAlignmentEnum,
} from 'bento-common/types';
import {
  ClientStorage,
  readFromClientStorage,
  removeFromClientStorage,
  saveToClientStorage,
} from 'bento-common/utils/clientStorage';
import {
  duplicateName,
  getGuideThemeFlags,
  getParsedMediaSettings,
  isGuideEligibleToHideCompletedSteps,
  isGuideInActiveSplitTest,
  isSplitTestGuide,
  isTemplateRankable,
} from 'bento-common/data/helpers';
import { capitalizeFirstLetter } from 'bento-common/utils/strings';

import { TemplateForm } from 'components/Templates/EditTemplate';
import { prepareTemplateModuleData, sanitizeModuleData } from 'helpers';
import useToast from 'hooks/useToast';

import * as CreateModuleMutation from 'mutations/CreateModule';

import { ModuleValue } from 'types';
import { getUrlQuery, showErrors } from 'utils/helpers';
import { TemplateFormValues } from 'components/Templates/Template';
import useWarnUnsavedChanges from 'hooks/useWarnUnsavedChanges';
import { MainFormKeys, MODULE_ALIAS_SINGULAR } from 'helpers/constants';
import { useFormsProvider } from './FormsProvider';
import { useAllModules } from './AllModulesProvider';
import { LS_KEYS } from 'bento-common/hooks/useClientStorage';
import { setAutoLaunchState } from 'components/GuideAutoLaunchModal/Template/autolaunch.helpers';
import { EditTemplateQuery } from 'relay-types/EditTemplateQuery.graphql';
import { useGuideSchedulingThrottling } from 'hooks/useFeatureFlag';
import { isEdgeToEdge } from 'bento-common/utils/image';
import { MediaType } from 'bento-common/types/media';
import { pickTagDataFromEditorState } from 'components/ContextTagEditor/constants';
import { WysiwygEditorAction } from 'components/WysiwygEditor/utils';
import { WYSIWYG_EDITOR_GUIDE_CONFIRMATION } from 'components/WysiwygEditor/constants';
import { isNil } from 'bento-common/utils/lodash';
import useActiveStepList from 'hooks/useActiveStepList';
import { templateNotFound } from 'components/EditorCommon/common';
import { sortRankableTargets } from 'components/Templates/Tabs/PriorityRankingForm/helpers';
import {
  BranchingType,
  StepPrototypeValue,
  TemplateModuleValue,
  TemplateValue,
} from 'bento-common/types/templateData';
import { fullModuleToTemplateModule } from 'components/Templates/EditTemplate/wysiwyg.helpers';
import { isFakeId } from 'bento-common/data/fullGuide';
import * as RemoveTemplateMutation from '../mutations/RemoveTemplate';
import { GroupTargeting } from 'bento-common/types/targeting';
import * as SetAutoLaunchRulesAndTargetsForTemplateMutation from 'mutations/SetAutoLaunchRulesAndTargetsForTemplate';
import { castTargetingRules } from 'components/EditorCommon/GroupTargetingEditor.helpers';
import { isDesignType, isFormFactor } from 'helpers/transformedHelpers';
import fetchAutoGeneratedContent from 'utils/fetchAutoGeneratedContent';
import { transformGeneratedGuideContent } from 'components/Templates/BentoAIBuilder/autoGenerateContent.helpers';
import useToggleState, { UseToggleStateReturn } from 'hooks/useToggleState';
import { useVisualBuilder } from './VisualBuilderProvider';
import { useGuideResetToast } from 'components/GuideResetToast';
import { TemplateTargetsInputType } from 'relay-types/SetAutoLaunchRulesAndTargetsForTemplateMutation.graphql';

type Template = TemplateForm;

type TemplateProviderProps = {
  children: any;
  template: Template;
  onFormDirty: (dirty: boolean) => void;
  autoLaunchableTemplates: EditTemplateQuery['response']['autoLaunchableTemplates'];
  launchedNpsSurveys: EditTemplateQuery['response']['launchedNpsSurveys'];
};

export type MediaReferenceFlags = {
  hasEdgeToEdge: boolean;
  hasVideo: boolean;
  hasImage: boolean;
  hasNumberAttribute: boolean;
};

type moduleSaveFn = ({ moduleData }: { moduleData: ModuleValue }) => void;

type Modals =
  | 'contentGenerating'
  | 'autoGenerate'
  | 'creatingModule'
  | 'bootstrap';

export interface TemplateProviderContextValue
  extends ReturnType<typeof getGuideThemeFlags> {
  template: Template;
  isTemplate: boolean;
  isTooltip: boolean;
  isFlow: boolean;
  isAnnouncement: boolean;
  isInline: boolean;
  isBanner: boolean;
  isModal: boolean;
  isSplitTest: boolean;
  isTargetedForSplitTesting: SplitTestState;
  namePlaceholder: string;
  isEverboarding: boolean;
  isOnboarding: boolean;
  multiModule: boolean;
  tempModuleRef: MutableRefObject<TemplateModuleValue>;
  handleSaveWithPropagation: () => Promise<void>;
  handleModuleDuplicate: moduleSaveFn;
  getNumberOfOtherTemplatesUsingModule: (moduleEntityId: string) => number;
  handleNewElementFromBranching: (branchingEntityType: BranchingType) => void;
  launchSchedule: {
    enableAutoLaunchAt: string | null;
    disableAutoLaunchAt: string | null;
  };
  setLaunchSchedule: (
    field: 'enableAutoLaunchAt' | 'disableAutoLaunchAt',
    // Formik requires a string, even if it's empty.
    value: string
  ) => void;
  expirationCriteria: {
    basedOn: GuideExpirationCriteria;
    after: number | null;
  };
  setExpirationCriteria: (
    basedOn: GuideExpirationCriteria,
    after: number | null
  ) => void;
  canEditTemplate: boolean;
  isUnsavedChangesModalOpen: boolean;
  isLaunchModalOpen: boolean;
  setIsLaunchModalOpen: (o: boolean) => void;
  handleCloseUnsavedChangesModal: () => void;
  handleContinueUnsavedChanges: () => Promise<void>;
  /** Currently used only for single step, single media guides. */
  mediaReferenceFlags: MediaReferenceFlags;
  handleSaveGuideBtnClick: (e: React.MouseEvent) => void;
  onChangesDiscarded: () => void;
  isLaunchScheduleConfirmationModalOpen: boolean;
  onConfirmLaunchSchedule: () => void;
  selectedStep: StepPrototypeValue | undefined;
  selectedTag: any;
  onCloseLaunchScheduleConfirmationModal: () => void;
  handleLaunchOrPause: (remove: boolean) => Promise<void>;
  launchPriority: number;
  setLaunchPriority: (i: number) => void;
  /** List of step group Ids used within branching paths */
  branchingStepGroupIds: string[];
  handleEditOrCreateTag: (
    stepPrototype: StepPrototypeValue | null | undefined,
    tagParentFormKey: string,
    action: WysiwygEditorAction,
    initialMode?: WysiwygEditorMode
  ) => void;
  handleDeleteTag: (tagParentFormKey: string) => void;
  handleTagUrlChange: (
    tagParentFormKey: string,
    newWildcardUrl: string,
    newUrl: string,
    newElementSelector?: string
  ) => void;
  handleEditOrCreateInlineEmbed: (
    action: WysiwygEditorAction,
    initialMode?: WysiwygEditorMode
  ) => void;
  handleDeleteInlineEmbed: () => void;
  handleInlineEmbedUrlChange: (
    newWildcardUrl: string,
    newUrl: string,
    newElementSelector?: string
  ) => void;
  setMediaPositionDefaults: ({
    newMediaType,
    newStepBodyOrientation,
  }: {
    newMediaType?: MediaType;
    newStepBodyOrientation?: StepBodyOrientation;
  }) => void;
  isTemplateContext: boolean;
  handleTargetingTypeChange: (newType: GuidePageTargetingType) => void;
  handleTargetingChange: (
    targeting: GroupTargeting,
    gptRequestId?: string
  ) => Promise<void>;
  setGuideTitles: (value: string) => void;
  /** Allow unsaved handler to auto commit changes */
  setTargetingDirtyHook: (dirtyCb: null | (() => void)) => void;
  /** Key to refresh a text input render when the data has changed */
  guideTitleInputKey: number;
  allStepsHaveATag: boolean;
  /** A loading state for edit template mutation */
  isSaving: boolean;
  /** A loading state for when we're waiting for a launch/pause */
  isLaunchingOrPausing: boolean;
  /** Allows us to block launching for pending changes */
  editingTargetingForm: boolean;
  setEditingTargetingForm: (editing: boolean) => void;
  /** Override targetingSet = false blocking launch button. Prevents re-fetch and re-init on main form */
  manuallyEnableLaunchButton: boolean;
  setManuallyEnableLaunchButton: (state: boolean) => void;
  /** Modals used across the template editor */
  modalStates: UseToggleStateReturn<Modals>;
  /** A random key used to force the RTE to re-render on-demand */
  rteRenderKey: string;
}

const TemplateProviderContext = createContext<TemplateProviderContextValue>({
  template: null,
  isTemplate: false,
  isAnnouncement: false,
  isTooltip: false,
  isFlow: false,
  namePlaceholder: null,
  isInline: false,
  isBanner: false,
  isModal: false,
  isCard: false,
  isFlat: false,
  isNested: false,
  isTimeline: false,
  isVideoGallery: false,
  isCompact: false,
  isCarousel: false,
  isSplitTest: false,
  isTargetedForSplitTesting: SplitTestState.none,
  multiModule: false,
  isEverboarding: false,
  isOnboarding: false,
  canEditTemplate: false,
  isUnsavedChangesModalOpen: false,
  isLaunchModalOpen: false,
  setIsLaunchModalOpen: () => {},
  tempModuleRef: null,
  handleSaveWithPropagation: async () => {},
  handleModuleDuplicate: (_) => {},
  getNumberOfOtherTemplatesUsingModule: (_) => 0,
  handleNewElementFromBranching: (_) => {},
  launchSchedule: {
    enableAutoLaunchAt: null,
    disableAutoLaunchAt: null,
  },
  setLaunchSchedule: noop,
  expirationCriteria: { basedOn: GuideExpirationCriteria.never, after: null },
  setExpirationCriteria: noop,
  handleCloseUnsavedChangesModal: () => {},
  guideTitleInputKey: 0,
  allStepsHaveATag: false,
  setGuideTitles: (_v) => {},
  handleSaveGuideBtnClick: (_) => {},
  handleContinueUnsavedChanges: async () => {},
  mediaReferenceFlags: {
    hasEdgeToEdge: false,
    hasVideo: false,
    hasImage: false,
    hasNumberAttribute: false,
  },
  onChangesDiscarded: () => {},
  isLaunchScheduleConfirmationModalOpen: false,
  onConfirmLaunchSchedule: noop,
  onCloseLaunchScheduleConfirmationModal: noop,
  handleLaunchOrPause: async () => {},
  launchPriority: 0,
  selectedStep: undefined,
  selectedTag: undefined,
  setLaunchPriority: (_) => {},
  branchingStepGroupIds: [],
  handleEditOrCreateTag: () => {},
  handleDeleteTag: () => {},
  handleTagUrlChange: () => {},
  handleEditOrCreateInlineEmbed: () => {},
  handleDeleteInlineEmbed: () => {},
  handleInlineEmbedUrlChange: () => {},
  setMediaPositionDefaults: (_) => {},
  handleTargetingTypeChange: () => {},
  handleTargetingChange: async () => {},
  setTargetingDirtyHook: (_) => {},
  isTemplateContext: false,
  isSaving: false,
  isLaunchingOrPausing: false,
  editingTargetingForm: false,
  setEditingTargetingForm: (_) => {},
  manuallyEnableLaunchButton: false,
  setManuallyEnableLaunchButton: (_) => {},
  modalStates: {} as any,
  rteRenderKey: '',
});

const CAPPED_ALIAS = capitalizeFirstLetter(MODULE_ALIAS_SINGULAR);
const formKey = MainFormKeys.template;

export function useTemplate() {
  return useContext(TemplateProviderContext);
}

export default function TemplateProvider({
  children,
  template,
  autoLaunchableTemplates,
  launchedNpsSurveys,
  onFormDirty,
}: TemplateProviderProps) {
  const modalStates = useToggleState([
    'contentGenerating',
    'autoGenerate',
    'creatingModule',
    'bootstrap',
  ]);

  /**
   * Common vars.
   */
  const [rteRenderKey, setRTERenderKey] = useState(uuidv4());
  const [isSaving, setIsSaving] = useState(false);
  const [isLaunchingOrPausing, setIsLaunchingOrPausing] = useState(false);
  const { values, dirty, isValid, submitForm, setFieldValue, resetForm } =
    useFormikContext<TemplateFormValues>();
  const [isUnsavedChangesModalOpen, setIsUnsavedChangesModalOpen] =
    useState<boolean>(false);
  const [shouldPreventPageChange, setShouldPreventPageChange] =
    useState<boolean>(true);
  const [editingTargetingForm, setEditingTargetingForm] = useState(false);
  const { launchVisualBuilderSession } = useVisualBuilder();
  // Used for the AI based builders
  // that set a new guide title. This forces
  // text inputs
  const [guideTitleInputKey, setGuideTitleInputKey] = useState<number>(0);
  const [isLaunchModalOpen, setIsLaunchModalOpen] = useState<boolean>(false);
  const [manuallyEnableLaunchButton, setManuallyEnableLaunchButton] =
    useState(false);
  const [launchPriority, setLaunchPriority] = useState(0);
  const isTargetedForSplitTesting =
    template.isTargetedForSplitTesting as SplitTestState;
  const canEditTemplate =
    !template.isTemplate &&
    !template.archivedAt &&
    !isGuideInActiveSplitTest(isTargetedForSplitTesting);
  const isSplitTest = useMemo(
    () => isSplitTestGuide(template.type as GuideTypeEnum),
    [template.type]
  );
  const targetingDirtyCallback = useRef<() => void>();
  const [targetingInProgress, setTargetingInProgress] = useState(false);

  const { setForms, submitForms, setFormConfirmed, isAnyFormDirty } =
    useFormsProvider();
  const throttlingEnabled = useGuideSchedulingThrottling();
  const theme = values.templateData.theme;

  const { runAutoCheck } = useGuideResetToast();

  useEffect(() => {
    runAutoCheck('template', [template.entityId]);
  }, [template.entityId]);

  const setTargetingDirtyHook = useCallback((cb: null | (() => void)) => {
    targetingDirtyCallback.current = cb;
    setTargetingInProgress(!!cb);
  }, []);

  const {
    isAnnouncement,
    isEverboarding,
    isOnboarding,
    isTooltip,
    isBanner,
    isInline,
    isModal,
    isFlow,
    ...themeFlags
  } = useMemo(
    () => ({
      isAnnouncement: isDesignType.announcement(template.designType),
      isEverboarding: isDesignType.everboarding(template.designType),
      isOnboarding: isDesignType.onboarding(template.designType),
      isTooltip: isFormFactor.tooltip(template.formFactor),
      isBanner: isFormFactor.banner(template.formFactor),
      isInline: isFormFactor.inline(template.formFactor),
      isFlow: isFormFactor.flow(template.formFactor),
      isModal: isFormFactor.modal(template.formFactor),
      ...getGuideThemeFlags(theme),
    }),
    [template.designType, template.formFactor, theme]
  );

  const multiModule = useMemo(
    () => values.templateData.modules.length > 1,
    [values.templateData.modules.length]
  );

  const currentStep = useActiveStepList();
  const selectedStep = isFlow
    ? values.templateData.modules[0].stepPrototypes[currentStep]
    : null;
  const selectedTag = selectedStep?.taggedElements?.[0];

  const namePlaceholder = useMemo(
    () =>
      'Guide title' +
      (isFlow || isTooltip || themeFlags.isCard || themeFlags.isCarousel
        ? ''
        : isAnnouncement
        ? ' (visible to users in "Resource center")'
        : ' (visible to users)'),
    [isFlow, isTooltip, themeFlags, isAnnouncement]
  );

  const { modules, fetchAllModules } = useAllModules();

  const toast = useToast();
  const router = useRouter();

  useEffect(() => {
    onFormDirty(dirty);
  }, [dirty]);

  const [
    isLaunchScheduleConfirmationModalOpen,
    setIsLaunchScheduleConfirmationModalOpen,
  ] = useState(false);

  const handleCloseLaunchScheduleConfirmationModal = useCallback(() => {
    setIsLaunchScheduleConfirmationModalOpen(false);
  }, []);

  const {
    enableAutoLaunchAt,
    disableAutoLaunchAt,
    expireBasedOn,
    expireAfter,
  } = values.templateData;

  const setGuideTitles = useCallback((value: string) => {
    setFieldValue(`templateData.name`, value);
    setFieldValue(`templateData.privateName`, value);
  }, []);

  const mediaReferenceFlags = useMemo(() => {
    const mediaReference =
      values.templateData?.modules?.[0]?.stepPrototypes?.[0]
        ?.mediaReferences?.[0];
    const { imageSettings } = getParsedMediaSettings(mediaReference?.settings);

    const result = {
      hasEdgeToEdge: isEdgeToEdge(imageSettings?.fill),
      hasVideo: mediaReference?.media?.type === MediaType.video,
      hasImage: mediaReference?.media?.type === MediaType.image,
      hasNumberAttribute:
        mediaReference?.media?.type === MediaType.numberAttribute,
      hasAny: false,
    };
    result.hasAny = Object.values(result).some(Boolean);

    return result;
  }, [values.templateData?.modules?.[0]?.stepPrototypes?.[0]]);

  const launchSchedule = useMemo<{
    enableAutoLaunchAt: string | null;
    disableAutoLaunchAt: string | null;
  }>(
    () => ({
      enableAutoLaunchAt: enableAutoLaunchAt || null,
      disableAutoLaunchAt: disableAutoLaunchAt || null,
    }),
    [enableAutoLaunchAt, disableAutoLaunchAt]
  );

  const setLaunchSchedule = useCallback<
    TemplateProviderContextValue['setLaunchSchedule']
  >(
    (field, value) => {
      setFieldValue(`templateData.${field}`, value);
    },
    [setFieldValue]
  );

  const expirationCriteria = useMemo<
    TemplateProviderContextValue['expirationCriteria']
  >(
    () => ({
      basedOn: expireBasedOn,
      after: expireAfter,
    }),
    [expireBasedOn, expireAfter]
  );

  const setExpirationCriteria = useCallback<
    TemplateProviderContextValue['setExpirationCriteria']
  >(
    (basedOn, after) => {
      setFieldValue(`templateData.expireBasedOn`, basedOn);
      setFieldValue(
        `templateData.expireAfter`,
        basedOn === GuideExpirationCriteria.never ? null : after
      );
    },
    [setFieldValue]
  );

  /* Set initial launch priority */
  useEffect(() => {
    const rankableObjects = sortRankableTargets([
      ...autoLaunchableTemplates.filter(isTemplateRankable),
      ...launchedNpsSurveys,
    ]);
    const order = rankableObjects.findIndex(
      (rankable) => rankable.entityId === template.entityId
    );

    setLaunchPriority(order === -1 ? rankableObjects.length : order);
  }, [autoLaunchableTemplates, launchedNpsSurveys, template.entityId]);

  /** Reset hideCompletedSteps if needed. */
  useEffect(() => {
    if (
      (values.templateData.formFactorStyle as ChecklistStyle)
        ?.hideCompletedSteps &&
      !isGuideEligibleToHideCompletedSteps(theme)
    ) {
      setFieldValue(`${formKey}.formFactorStyle.hideCompletedSteps`, false);
    }
  }, [theme]);

  const setMediaPositionDefaults = useCallback(
    ({
      newMediaType,
      newStepBodyOrientation,
    }: {
      newMediaType?: MediaType;
      newStepBodyOrientation?: StepBodyOrientation;
    }) => {
      const hasAny = newMediaType || mediaReferenceFlags.hasAny;
      const hasNumberAttribute =
        newMediaType === MediaType.numberAttribute ||
        mediaReferenceFlags.hasNumberAttribute;
      const stepBodyOrientation =
        newStepBodyOrientation ||
        (values.templateData.formFactorStyle as CardStyle)?.stepBodyOrientation;

      // Reset fixed width if media is not of image type.
      if (
        !isNil(
          (values.templateData.formFactorStyle as CardStyle)?.imageWidth
        ) &&
        hasAny
      ) {
        setFieldValue(`${formKey}.formFactorStyle.imageWidth`, undefined);
      }

      // Set default orientation and alignment for guides
      // with media.
      if (stepBodyOrientation === StepBodyOrientation.horizontal && hasAny) {
        setFieldValue(
          `${formKey}.formFactorStyle.verticalMediaAlignment`,
          VerticalAlignmentEnum.center
        );
        setFieldValue(
          `${formKey}.formFactorStyle.mediaOrientation`,
          hasNumberAttribute ? MediaOrientation.Left : MediaOrientation.Right
        );
      }
    },
    [mediaReferenceFlags, values.templateData.formFactorStyle, formKey]
  );

  // Keep track of a module edited within a template.
  const tempModuleRef = useRef<TemplateModuleValue | null>(null);

  /**
   * Template actions.
   */

  const onChangesDiscarded = useCallback(() => {
    handleDiscardUnsavedChanges();
    goAwayIfIntended();
  }, []);

  const handleSaveWithPropagation = useCallback(async () => {
    setFormConfirmed(formKey, submitForm);
  }, [dirty, setFieldValue, submitForm, setFormConfirmed]);

  const handleDiscardUnsavedChanges = useCallback(() => {
    setIsUnsavedChangesModalOpen(false);
    setShouldPreventPageChange(false);
  }, []);

  const handleUnsavedChanges = useCallback((intendedUrl: string) => {
    if (canEditTemplate) {
      setIsUnsavedChangesModalOpen(true);
      return;
    }
    handleDiscardUnsavedChanges();
  }, []);

  const isDirtyState = isAnyFormDirty || targetingInProgress;

  const { goAwayIfIntended } = useWarnUnsavedChanges(
    isDirtyState && shouldPreventPageChange,
    handleUnsavedChanges,
    // allow switching to URLs following this pattern: /library/templates/[uuid]?tab=*
    [
      /^\/library\/templates\/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\?tab=[^.$]+$/,
    ]
  );

  const handleCloseUnsavedChangesModal = useCallback(
    () => setIsUnsavedChangesModalOpen(false),
    []
  );

  const { isAutoLaunchEnabled } = template;

  const handlePropagationWithSubmit = useCallback(async () => {
    // Prompt the user to confirm the launch/stop schedule anytime a date is set for either field when
    // the field currently is not set.
    if (
      (enableAutoLaunchAt && !template.enableAutoLaunchAt) ||
      (disableAutoLaunchAt && !template.disableAutoLaunchAt)
    ) {
      setIsLaunchScheduleConfirmationModalOpen(true);
      return;
    }

    const { error, needsPropagation } = dirty
      ? { error: null, needsPropagation: true }
      : { error: null, needsPropagation: false };

    if (error) return;
    if (needsPropagation) {
      await handleSaveWithPropagation();
      return;
    }

    setFormConfirmed(formKey, submitForm);
  }, [
    submitForm,
    dirty,
    isAutoLaunchEnabled,
    enableAutoLaunchAt,
    disableAutoLaunchAt,
  ]);

  useEffect(() => {
    setForms([
      {
        formKey,
        dirty,
        isValid,
        submitForm: handlePropagationWithSubmit,
        confirmed: false,
        resetForm,
      },
    ]);
  }, [
    dirty,
    isValid,
    handlePropagationWithSubmit,
    setForms,
    submitForm,
    resetForm,
  ]);

  const handleSaveGuideBtnClick = useCallback(
    async (e: React.MouseEvent) => {
      try {
        setIsSaving(true);
        targetingDirtyCallback.current = null;
        setTargetingInProgress(false);
        e.stopPropagation();
        await submitForms();
      } finally {
        setIsSaving(false);
      }
    },
    [submitForms]
  );

  /**
   * Module actions.
   */

  const handleModuleDuplicate = useCallback(
    async ({ moduleData }) => {
      try {
        const moduleDataCopy = {
          ...moduleData,
          name: duplicateName(moduleData.name || ''),
        };

        const sanitizedModuleData = sanitizeModuleData(
          moduleDataCopy,
          template.theme as Theme
        );

        const result = await CreateModuleMutation.commit({
          moduleData: sanitizedModuleData,
        });

        if (result?.createModule?.errors?.length) {
          throw result.createModule.errors;
        }

        const moduleCopy = result?.createModule?.module;

        toast({
          title: `${CAPPED_ALIAS} duplicated!`,
          isClosable: true,
          status: 'success',
        });

        // Update available modules array.
        fetchAllModules();

        return {
          ...prepareTemplateModuleData(moduleCopy, template.theme as Theme),
        };
      } catch (e) {
        showErrors(e, toast);
        return null;
      }
    },
    [fetchAllModules]
  );

  const getNumberOfOtherTemplatesUsingModule = (moduleEntityId: string) => {
    if (!moduleEntityId || isFakeId(moduleEntityId)) return 0;
    const module = [...modules, ...template.modules].find(
      (module) => module.entityId === moduleEntityId
    );
    return (module?.templates || []).filter(
      (t) => t.entityId !== template.entityId
    ).length;
  };

  /**
   * Branching actions.
   */
  const handleNewElementFromBranching = useCallback(
    (branchingEntityType: BranchingType) => {
      toast({
        title:
          branchingEntityType === BranchingType.guide
            ? 'Template created!'
            : `${CAPPED_ALIAS} created!`,
        isClosable: true,
        status: 'success',
      });

      // Update available modules array.
      fetchAllModules();
    },
    [fetchAllModules]
  );

  /**
   * @todo review this logic
   */
  const setTemplateFormikData = useCallback(
    debounce((data: TemplateValue) => {
      saveToClientStorage(
        ClientStorage.localStorage,
        LS_KEYS.PreviewInitData,
        data
      );
    }, 1000),
    []
  );

  /**
   * Open the WYSIWYG editor for newly created templates.
   */
  useEffect(() => {
    const onCreateBehavior = getUrlQuery('behavior', 'all');

    switch (onCreateBehavior) {
      case OnCreateBehavior.openAiModal: {
        if (isFlow) {
          handleAutoFlowBuilder();
        } else {
          modalStates.autoGenerate.on();
        }

        break;
      }
      case OnCreateBehavior.openVisualBuilder: {
        if (isTooltip) {
          handleEditOrCreateTag(
            null,
            MainFormKeys.template,
            WysiwygEditorAction.create
          );
        } else if (isFlow) {
          handleEditOrCreateTag(
            values.templateData.modules?.[0]?.stepPrototypes?.[0],
            `${MainFormKeys.template}.modules[0].stepPrototypes[0]`,
            WysiwygEditorAction.create
          );
        } else if (isInline) {
          handleEditOrCreateInlineEmbed(WysiwygEditorAction.create);
        }

        break;
      }
    }
  }, []);

  useEffect(() => {
    setTemplateFormikData(values.templateData);
  }, [values.templateData]);

  useEffect(() => {
    () => {
      removeFromClientStorage(
        ClientStorage.localStorage,
        LS_KEYS.PreviewInitData
      );
    };
  }, []);

  const handleContinueUnsavedChanges = useCallback(async () => {
    targetingDirtyCallback.current?.();
    /** Timeout bc the callback may alter state that affects next steps */
    setTimeout(
      () => {
        handleCloseUnsavedChangesModal();
        handlePropagationWithSubmit();
        targetingDirtyCallback.current = null;
        setTargetingInProgress(false);
      },
      targetingDirtyCallback.current ? 300 : 0
    );
  }, [handlePropagationWithSubmit, targetingDirtyCallback.current]);

  const handleLaunchOrPause = useCallback(
    async (remove: boolean) => {
      try {
        setIsLaunchingOrPausing(true);

        if (remove) {
          await RemoveTemplateMutation.commit({
            templateEntityId: template.entityId,
          });

          toast({
            title: 'Guide removed',
            isClosable: true,
            status: 'success',
          });
        } else {
          await setAutoLaunchState(
            template.entityId,
            throttlingEnabled ? false : !isAutoLaunchEnabled
          );

          toast.closeAll();
          toast({
            title: 'Auto-launch settings updated!',
            isClosable: true,
            status: 'success',
          });
        }
      } catch (e) {
        toast({
          title: e.message || 'Something went wrong',
          isClosable: true,
          status: 'error',
        });
      } finally {
        setIsLaunchingOrPausing(false);
        setIsLaunchModalOpen(false);
      }
    },
    [toast, template.entityId, isAutoLaunchEnabled]
  );

  /**
   * @todo replace by a controlled state to reduce re-computation
   */
  const branchingStepGroupIds = useMemo<string[]>(() => {
    if (!values.templateData?.modules) return [];

    const branchingStepGroupIds: string[] = [];
    values.templateData?.modules.forEach((m) => {
      m.stepPrototypes?.forEach((s) => {
        if (
          !s.branchingPathData?.length ||
          s.branchingEntityType !== BranchingType.module
        ) {
          return;
        }
        s.branchingPathData.forEach((data) => {
          if (!data.moduleEntityId) return;
          branchingStepGroupIds.push(data.moduleEntityId);
        });
      });
    });

    return branchingStepGroupIds;
  }, [values.templateData?.modules]);

  const handleEditOrCreateTag = useCallback(
    async (
      stepPrototype: StepPrototypeValue | null | undefined,
      tagParentFormKey: string,
      action: WysiwygEditorAction,
      initialMode?: WysiwygEditorMode
    ) => {
      const mode =
        initialMode ||
        (action === WysiwygEditorAction.edit
          ? WysiwygEditorMode.preview
          : undefined);

      const progressData = await launchVisualBuilderSession({
        type: VisualBuilderSessionType.Tag,
        baseUrl: `/tags/${action}`,
        initialData: {
          templateData: values.templateData,
          tagParentFormKey,
          stepPrototype,
          mode,
        },
      });

      if (progressData) {
        const newTemplateModule = fullModuleToTemplateModule(
          progressData.data.guide.modules[0],
          progressData.data.allTaggedElements,
          values.templateData.modules[0]
        );

        setFieldValue(`${MainFormKeys.template}.modules[0]`, newTemplateModule);

        if (isTooltip) {
          const newTaggedElement = pickTagDataFromEditorState(progressData);

          setFieldValue(
            `${tagParentFormKey}.taggedElements[0]`,
            newTaggedElement
          );
        }

        toast({
          title: WYSIWYG_EDITOR_GUIDE_CONFIRMATION,
          isClosable: true,
          status: 'info',
          duration: 7000,
        });
      }

      /**
       * Force the RTE to re-render with the new content
       */
      setRTERenderKey(uuidv4());
    },
    [values.templateData, isFlow]
  );

  /**
   * Currently only used for single step group
   * guides.
   */
  const allStepsHaveATag = useMemo(() => {
    return !values.templateData?.modules?.[0]?.stepPrototypes?.some(
      (s) => !s.taggedElements?.[0]
    );
  }, [values.templateData?.modules?.[0]]);

  const handleDeleteTag = useCallback((tagParentFormKey: string) => {
    setFieldValue(`${tagParentFormKey}.taggedElements`, []);
  }, []);

  const handleTargetingTypeChange = useCallback(
    (newType: GuidePageTargetingType) => {
      setFieldValue(`${MainFormKeys.template}.pageTargetingType`, newType);
    },
    []
  );

  const handleTargetingChange = useCallback(
    async (targeting: GroupTargeting, gptRequestId?: string) => {
      try {
        setIsSaving(true);

        await SetAutoLaunchRulesAndTargetsForTemplateMutation.commit({
          templateEntityId: template.entityId,
          isAutoLaunchEnabled,
          targets: castTargetingRules(targeting) as TemplateTargetsInputType,
          gptRequestId,
        });

        toast.closeAll();
        toast({
          title: 'Auto-launch settings updated!',
          isClosable: true,
          status: 'success',
        });
      } catch (e) {
        toast({
          title: e.message || 'Something went wrong',
          isClosable: true,
          status: 'error',
        });
      } finally {
        setIsSaving(false);
      }
    },
    [toast, template.entityId, isAutoLaunchEnabled]
  );

  const handleTagUrlChange = useCallback(
    (
      tagParentFormKey: string,
      newWildcardUrl: string,
      newUrl: string,
      newElementSelector?: string
    ) => {
      const formKey = `${tagParentFormKey}.taggedElements[0]`;
      setFieldValue(`${formKey}.wildcardUrl`, newWildcardUrl);
      setFieldValue(`${formKey}.url`, newUrl);
      if (typeof newElementSelector !== 'undefined') {
        setFieldValue(`${formKey}.elementSelector`, newElementSelector);
      }
    },
    []
  );

  const handleEditOrCreateInlineEmbed = useCallback(
    async (action: WysiwygEditorAction, initialMode?: WysiwygEditorMode) => {
      const mode =
        initialMode ||
        (action === WysiwygEditorAction.edit
          ? WysiwygEditorMode.preview
          : undefined);

      const progressData = await launchVisualBuilderSession({
        type: VisualBuilderSessionType.Inline,
        baseUrl: `/inline-injection/${action}`,
        initialData: {
          templateData: values.templateData,
          mode,
        },
      });

      if (progressData) {
        setFieldValue(`${MainFormKeys.template}.inlineEmbed`, {
          ...(values.templateData.inlineEmbed || {}),
          ...pick(progressData.data.inlineEmbed, [
            'entityId',
            'position',
            'topMargin',
            'rightMargin',
            'bottomMargin',
            'padding',
            'borderRadius',
            'leftMargin',
            'alignment',
            'maxWidth',
          ]),
          ...pick(progressData, [
            'elementSelector',
            'url',
            'wildcardUrl',
            'entityId',
          ]),
        });
        toast({
          title: WYSIWYG_EDITOR_GUIDE_CONFIRMATION,
          isClosable: true,
          status: 'info',
          duration: 7000,
        });
      }

      /**
       * Force the RTE to re-render with the new content
       */
      setRTERenderKey(uuidv4());
    },
    [values.templateData]
  );

  const handleAutoFlowBuilder = useCallback(async () => {
    const progressData = await launchVisualBuilderSession({
      type: VisualBuilderSessionType.AutoGuideBuilder,
      baseUrl: `/auto-guide-builder/new`,
      initialData: {
        templateEntityId: values.templateData.entityId,
      },
    });

    if (progressData) {
      try {
        const { recordedActions, pageText } =
          progressData as WysiwygEditorState<AutoGuideBuilderData>;

        if (recordedActions.length) {
          modalStates.contentGenerating.on();

          const actionsString = recordedActions
            .map((ra) => ra.action)
            .join('/n');

          const res = await fetchAutoGeneratedContent({
            accessToken: readFromClientStorage(
              ClientStorage.localStorage,
              'accessToken'
            ),
            templateEntityId: values.templateData.entityId,
            transcript: actionsString,
            pageText,
          });

          const content = res.choices[0];

          const newModule = transformGeneratedGuideContent(
            content,
            recordedActions
          );

          if (newModule) {
            /**
             * Use the ID of the existing module to
             * prevent creating a new one.
             */
            newModule.entityId =
              values.templateData.modules[0]?.entityId || newModule.entityId;

            setGuideTitles(newModule.name);
            // Force the template title to refresh with the new auto-generated title
            setGuideTitleInputKey(Math.random());
            setFieldValue(`${MainFormKeys.template}.modules[0]`, newModule);
          }
        }
      } finally {
        modalStates.contentGenerating.off();
      }
    }

    /**
     * Force the RTE to re-render with the new content
     */
    setRTERenderKey(uuidv4());
  }, [values.templateData]);

  const handleDeleteInlineEmbed = useCallback(
    () => setFieldValue(`${MainFormKeys.template}.inlineEmbed`, null),
    []
  );

  const handleInlineEmbedUrlChange = useCallback(
    (newWildcardUrl: string, newUrl: string, newElementSelector?: string) => {
      const formKey = `${MainFormKeys.template}.inlineEmbed`;

      setFieldValue(`${formKey}.wildcardUrl`, newWildcardUrl);
      setFieldValue(`${formKey}.url`, newUrl);
      if (typeof newElementSelector !== 'undefined') {
        setFieldValue(`${formKey}.elementSelector`, newElementSelector);
      }
    },
    []
  );

  const onConfirmLaunchSchedule = useCallback(async () => {
    try {
      setIsSaving(true);
      await submitForm();
    } finally {
      setIsSaving(false);
    }
  }, [submitForm]);

  if (!template) {
    templateNotFound(router, toast);
    return null;
  }

  return (
    <TemplateProviderContext.Provider
      // TODO: A good prop to memoize.
      value={{
        template,
        isTemplate: template.isTemplate,
        namePlaceholder,
        handleContinueUnsavedChanges,
        handleSaveGuideBtnClick,
        multiModule,
        tempModuleRef,
        handleSaveWithPropagation,
        handleModuleDuplicate,
        setMediaPositionDefaults,
        mediaReferenceFlags,
        getNumberOfOtherTemplatesUsingModule,
        handleNewElementFromBranching,
        launchSchedule,
        setLaunchSchedule,
        expirationCriteria,
        setExpirationCriteria,
        isAnnouncement,
        isEverboarding,
        isOnboarding,
        isTooltip,
        isFlow,
        isBanner,
        isInline,
        isSplitTest,
        isTargetedForSplitTesting,
        isModal,
        onChangesDiscarded,
        canEditTemplate,
        isUnsavedChangesModalOpen,
        isLaunchModalOpen,
        setIsLaunchModalOpen,
        handleCloseUnsavedChangesModal,
        isLaunchScheduleConfirmationModalOpen,
        handleLaunchOrPause,
        onConfirmLaunchSchedule,
        onCloseLaunchScheduleConfirmationModal:
          handleCloseLaunchScheduleConfirmationModal,
        launchPriority,
        setLaunchPriority,
        branchingStepGroupIds,
        handleEditOrCreateTag,
        handleDeleteTag,
        handleTargetingTypeChange,
        handleTargetingChange,
        handleTagUrlChange,
        handleEditOrCreateInlineEmbed,
        handleDeleteInlineEmbed,
        setTargetingDirtyHook,
        selectedStep,
        selectedTag,
        handleInlineEmbedUrlChange,
        setGuideTitles,
        guideTitleInputKey,
        allStepsHaveATag,
        isTemplateContext: true,
        isSaving,
        isLaunchingOrPausing,
        editingTargetingForm,
        setEditingTargetingForm,
        manuallyEnableLaunchButton,
        setManuallyEnableLaunchButton,
        modalStates,
        rteRenderKey,
        ...themeFlags,
      }}
    >
      {children}
    </TemplateProviderContext.Provider>
  );
}
